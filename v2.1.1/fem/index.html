<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Finite Element Method · MinFEM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MinFEM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MinFEM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>The Finite Element Method</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../paraview/">Visualization</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/poisson/">A Poisson Problem</a></li><li><a class="tocitem" href="../examples/boundary_source/">A Boundary Source Problem</a></li><li><a class="tocitem" href="../examples/elasticity/">A Vector-Valued Problem</a></li><li><a class="tocitem" href="../examples/semilinear/">A Semi-Linear Problem</a></li><li><a class="tocitem" href="../examples/parabolic/">A Time-Dependent Problem</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../lib/public/">Public</a></li><li><a class="tocitem" href="../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Finite Element Method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Finite Element Method</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MinFEM/MinFEM.jl/blob/master/docs/src/fem.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Closer-Look-on-a-Finite-Element-Code"><a class="docs-heading-anchor" href="#A-Closer-Look-on-a-Finite-Element-Code">A Closer Look on a Finite Element Code</a><a id="A-Closer-Look-on-a-Finite-Element-Code-1"></a><a class="docs-heading-anchor-permalink" href="#A-Closer-Look-on-a-Finite-Element-Code" title="Permalink"></a></h1><p>This section is designed to give a small introduction to the implementation of a finite element method, illustrated for 2 dimensions.</p><ul><li><a href="#A-Closer-Look-on-a-Finite-Element-Code">A Closer Look on a Finite Element Code</a></li><li class="no-marker"><ul><li class="no-marker"><ul><li><a href="#The-Reference-Element">The Reference Element</a></li><li><a href="#Local-Basis-Functions-on-T">Local Basis Functions on <span>$T$</span></a></li><li><a href="#The-Global-Basis-Functions">The Global Basis Functions</a></li><li><a href="#Quadrature-Nodes-on-Triangles">Quadrature Nodes on Triangles</a></li><li><a href="#Using-Quadrature-Formulas">Using Quadrature Formulas</a></li><li><a href="#Mapping-Reference-to-Physical-Elements">Mapping Reference to Physical Elements</a></li><li><a href="#Integration-Over-the-Reference-Element-via-Transformation-Formula">Integration Over the Reference Element via Transformation Formula</a></li><li><a href="#Mapping-From-Local-to-Global-Nodes">Mapping From Local to Global Nodes</a></li><li><a href="#Link-Between-Global-and-Local-Basis-Functions">Link Between Global and Local Basis Functions</a></li><li><a href="#Mass-Matrix-Assembly">Mass Matrix Assembly</a></li><li><a href="#Treatment-of-Terms-With-Derivatives">Treatment of Terms With Derivatives</a></li><li><a href="#Towards-the-Stiffness-Matrix-for-the-Laplacian">Towards the Stiffness Matrix for the Laplacian</a></li><li><a href="#Example-Calculation-for-the-Stiffness-Matrix">Example Calculation for the Stiffness Matrix</a></li></ul></li></ul></li></ul><h3 id="The-Reference-Element"><a class="docs-heading-anchor" href="#The-Reference-Element">The Reference Element</a><a id="The-Reference-Element-1"></a><a class="docs-heading-anchor-permalink" href="#The-Reference-Element" title="Permalink"></a></h3><p>The first thing we will cover is the so-called reference element. This is a prototypic element such that we later do not have to define everything for each actual element, but can do it in a generic way. MinFEM uses tetrahedral elements and the reference element is thus given by the <span>$d$</span>-dimensional standard simplex</p><p class="math-container">\[T = \left\lbrace x \in [0,1]^d:\, \sum_{j=1}^d x_j \leq 1\right\rbrace.\]</p><p>For this guide, we will work mostly in 2D, where this is simply the reference triangle</p><p class="math-container">\[T = \lbrace x \in [0,1]^2:\, x_1+x_2 \leq 1\rbrace.\]</p><p><img src="../assets/fem/reference_element.svg" alt="Reference Element"/></p><h3 id="Local-Basis-Functions-on-T"><a class="docs-heading-anchor" href="#Local-Basis-Functions-on-T">Local Basis Functions on <span>$T$</span></a><a id="Local-Basis-Functions-on-T-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Basis-Functions-on-T" title="Permalink"></a></h3><p>On <span>$T$</span> we can define order <span>$p=1$</span> Lagrange Polynomials</p><p class="math-container">\[\phi: T \to \mathbb{R}\]</p><p>using the vertices <span>$v_l, l=1,...,d+1$</span> as nodes such that</p><p class="math-container">\[\phi_l(v_{l^\prime}) = \delta_{l,l^\prime}\]</p><p>we obtain the basis functions</p><p class="math-container">\[\phi_l(x) = \begin{cases}
    1 - \sum_{j=1}^d x_j &amp; \text{if } l = 1\\
    x_{l-1} &amp; \text{else}
\end{cases}\]</p><p>in 2 dimension looking the following:</p><p><img src="../assets/fem/local_basis.svg" alt="Local Basis Functions"/></p><h3 id="The-Global-Basis-Functions"><a class="docs-heading-anchor" href="#The-Global-Basis-Functions">The Global Basis Functions</a><a id="The-Global-Basis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-Global-Basis-Functions" title="Permalink"></a></h3><p>On a patch of, e.g., five physical triangles we then have a global basis function  <span>$\Phi_i: \Omega \to \mathbb{R}$</span> of the following form:</p><p><img src="../assets/fem/global_basis.svg" alt="Global Basis Function"/></p><p>Since with each node <span>$x_i$</span> in the mesh one global basis function <span>$\Phi_i$</span> is associated we have the property</p><p class="math-container">\[\Phi_i(x_j) = \delta_{i,j}.\]</p><h3 id="Quadrature-Nodes-on-Triangles"><a class="docs-heading-anchor" href="#Quadrature-Nodes-on-Triangles">Quadrature Nodes on Triangles</a><a id="Quadrature-Nodes-on-Triangles-1"></a><a class="docs-heading-anchor-permalink" href="#Quadrature-Nodes-on-Triangles" title="Permalink"></a></h3><p>The next step is to define some quadrature nodes with weights on <span>$T$</span>. In principle, every set of distinct nodes with appropriate weights can be used for  quadrature.  Here we use a tensorproduct Gauss formula, since for these types the approximation order is known.</p><p><img src="../assets/fem/quadrature.svg" alt="Quadrature Formula"/></p><p>The presented quadrature rule allows exact integration of polynomials of order up to p=3.</p><h3 id="Using-Quadrature-Formulas"><a class="docs-heading-anchor" href="#Using-Quadrature-Formulas">Using Quadrature Formulas</a><a id="Using-Quadrature-Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Quadrature-Formulas" title="Permalink"></a></h3><p>In principle, we could integrate terms like </p><p class="math-container">\[\Phi_i \Phi_j\]</p><p>or </p><p class="math-container">\[\nabla \Phi_i \cdot \nabla \Phi_j\]</p><p>analytically since we only consider <span>$p=1$</span> Lagrange elements.</p><p>It is yet convenient to use quadrature formulas for, e.g., a nonlinear source term.</p><h3 id="Mapping-Reference-to-Physical-Elements"><a class="docs-heading-anchor" href="#Mapping-Reference-to-Physical-Elements">Mapping Reference to Physical Elements</a><a id="Mapping-Reference-to-Physical-Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-Reference-to-Physical-Elements" title="Permalink"></a></h3><p>In order to integrate over a physical triangle in the mesh <span>$T_k$</span>, we need to establish a mapping between <span>$T_k$</span> and the reference element <span>$T$</span> via a function</p><p class="math-container">\[\psi_k: T \to T_k.\]</p><p><img src="../assets/fem/physical_element.svg" alt="Physical Element"/></p><h3 id="Integration-Over-the-Reference-Element-via-Transformation-Formula"><a class="docs-heading-anchor" href="#Integration-Over-the-Reference-Element-via-Transformation-Formula">Integration Over the Reference Element via Transformation Formula</a><a id="Integration-Over-the-Reference-Element-via-Transformation-Formula-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-Over-the-Reference-Element-via-Transformation-Formula" title="Permalink"></a></h3><p>For linear finite elements with the chosen reference element <span>$T$</span> we can map each point <span>$r \in T$</span> to a <span>$x \in T_k$</span> by the affine mapping</p><p class="math-container">\[x = \psi_k(r) = J_k r + b_k.\]</p><p>Here <span>$J_k \in \mathbb{R}^{2\times 2}$</span> and <span>$b_k\in \mathbb{R}^2$</span> is constant for each triangle.</p><p><img src="../assets/fem/mapping.svg" alt="Element Mapping"/></p><p>Further, let <span>$w_1, w_2, w_3$</span> be the vertices of the triangle <span>$T_k$</span>. The matrix <span>$J_k$</span> is then given by</p><p class="math-container">\[J_k = [w_2 - w_1 \vert w_3 - w_1] \quad \text{and} \quad b_k = w_1.\]</p><p>Integration of a function <span>$f \in L^1(T_k)$</span> over <span>$T_k$</span> is thus performed by integration over <span>$T$</span> as</p><p class="math-container">\[\begin{aligned}
\int_{T_k} f(x) dx &amp;= \int_{T} f(\psi_k(x))\, \vert\det(D\psi_k(x))\vert \, dx\\
&amp;= \int_{T} f(\psi_k(x))  \, \vert\det(J_k)\vert \, dx.
\end{aligned}\]</p><p>By ensuring that in all physical elements <span>$T_k$</span> the node numbering is counter clockwise, like in the reference element <span>$T$</span>, it follows <span>$\det(J_k) \geq 0$</span> and we can omit the modulus. Moreover, as long as <span>$T_k$</span> is not degenerated it follows <span>$\det(J_k) &gt; 0$</span>.</p><h3 id="Mapping-From-Local-to-Global-Nodes"><a class="docs-heading-anchor" href="#Mapping-From-Local-to-Global-Nodes">Mapping From Local to Global Nodes</a><a id="Mapping-From-Local-to-Global-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-From-Local-to-Global-Nodes" title="Permalink"></a></h3><p>For every finite element code the mapping from local nodes in each triangle to the corresponding global node numbers is essential.</p><p>Let the mesh be given by the triangles <span>$\lbrace T_1,\dots, T_K\rbrace$</span> and a number of <span>$N$</span> nodes and thus the global basis functions.</p><p>For this mesh we assume a given map </p><p class="math-container">\[\eta:\lbrace 1, \dots, K\rbrace \times \lbrace1,2,3\rbrace \to \lbrace 1, \dots, N\rbrace,
\; \eta(k,l) = i\]</p><p>which assigns the <span>$l$</span>-th node in the <span>$k$</span>-th triangle the corresponding global node <span>$i$</span>.</p><p class="math-container">\[\Phi_i: \Omega \to \mathbb{R},\; i=1,\dots,N.\]</p><p>Further observe that</p><p class="math-container">\[\mathrm{spt}(\Phi_i) \subset \lbrace T_1,\dots, T_K\rbrace.\]</p><p>More precisely</p><p class="math-container">\[\mathrm{spt}(\Phi_i) = \lbrace T_k: \exists (k,l) \in \lbrace 1, \dots, K\rbrace \times
\lbrace1,2,3\rbrace\; \text{with}\; \eta(k,l) = i \rbrace\]</p><h3 id="Link-Between-Global-and-Local-Basis-Functions"><a class="docs-heading-anchor" href="#Link-Between-Global-and-Local-Basis-Functions">Link Between Global and Local Basis Functions</a><a id="Link-Between-Global-and-Local-Basis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Link-Between-Global-and-Local-Basis-Functions" title="Permalink"></a></h3><p>Let the global basis function <span>$\Phi_i:\Omega \to \mathbb{R}$</span> be associated with the node <span>$i$</span>.</p><p>We then have the property that</p><p class="math-container">\[\Phi_i (x) = \phi_l(\psi^{-1}_k(x))\quad \forall\, x\in T_k.\]</p><p>provided that <span>$\eta(k,l) = i$</span>.</p><p>Thus, we can use the following relation for integration on physical elements</p><p class="math-container">\[\Phi_i(\psi_k(x)) = \phi_{l}(x) \quad \forall \, x \in T.\]</p><h3 id="Mass-Matrix-Assembly"><a class="docs-heading-anchor" href="#Mass-Matrix-Assembly">Mass Matrix Assembly</a><a id="Mass-Matrix-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-Matrix-Assembly" title="Permalink"></a></h3><p>Recall that one entry of the mass matrix is given by</p><p class="math-container">\[\begin{aligned}
M_{i,j} &amp;= \int_{\Omega} \Phi_i(x) \Phi_j(x)\, dx\\
        &amp;= \sum_{k=1}^K \int_{T_k} \Phi_i(x) \Phi_j(x)\, dx\\
        &amp;= \sum_{k=1}^K \int_{T_k} \phi_l(\psi^{-1}_k(x)) \phi_h(\psi^{-1}_k(x))\, dx\\
        &amp;= \sum_{k=1}^K \int_{T} \phi_l(x) \phi_h(x) \vert \mathrm{det}(J_k)\vert\, dx
\end{aligned}\]</p><p>provided that <span>$\eta(k,l) = i$</span> and <span>$\eta(k,h) = j$</span>. In principal, the sum above involves many vanishing summands. It is sufficient to sum over all <span>$T_k \in \mathrm{spt}(\Phi_i) \cap \mathrm{spt}(\Phi_j)$</span>.</p><p>In order to assemble this matrix for <span>$1\leq i,j \leq N$</span> it is algorithmically more efficient to iterate over triangles rather than iterating over global basis functions by <span>$i$</span> and <span>$j$</span>.</p><p>We thus compute the following</p><p class="math-container">\[M_{n(k,l), n(k,h)} \gets M_{n(k,l), n(k,h)} + \int_{T} \phi_l(x) \phi_h(x)
    \vert \mathrm{det}(J_k)\vert\, dx \quad \forall\, (k,h,l)
    \in \lbrace1,\dots,K\rbrace\times \lbrace 1,2,3 \rbrace^2\]</p><p>This saves us the computational effort to find out which <span>$T_k$</span> is in <span>$\mathrm{spt}(\Phi_i) \cap \mathrm{spt}(\Phi_j)$</span>.</p><h3 id="Treatment-of-Terms-With-Derivatives"><a class="docs-heading-anchor" href="#Treatment-of-Terms-With-Derivatives">Treatment of Terms With Derivatives</a><a id="Treatment-of-Terms-With-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Treatment-of-Terms-With-Derivatives" title="Permalink"></a></h3><p>In the following we understand derivatives as row vectors</p><p class="math-container">\[D \phi = (\partial_1 \phi, \partial_2 \phi)\]</p><p>and the Jacobian matrix of a vector valued function, e.g. the element transformation, as</p><p class="math-container">\[D \psi = 
\begin{pmatrix}
\partial_1 \psi_1 &amp; \partial_2 \psi_1\\
\partial_1 \psi_2 &amp; \partial_2 \psi_2
\end{pmatrix}.\]</p><p>For terms which involve gradients we first observe that</p><p class="math-container">\[D \Phi_i(x) = D \phi_l(\psi_k^{-1}(x)) D \psi_k^{-1} =
D \phi_l(\psi_k^{-1}(x)) J_k^{-1}\quad \forall\, x\in T_k\]</p><p>provided that <span>$\eta(k,l) = i$</span>. And thus</p><p class="math-container">\[D \Phi_i(\psi_k(x)) = D \phi_l(x) J_k^{-1}\quad \forall \, x \in T.\]</p><p>Due to the fact that we only consider piece-wise linear basis functions we obtain</p><p class="math-container">\[D \Phi_i = D\phi_l J_k^{-1}.\]</p><h3 id="Towards-the-Stiffness-Matrix-for-the-Laplacian"><a class="docs-heading-anchor" href="#Towards-the-Stiffness-Matrix-for-the-Laplacian">Towards the Stiffness Matrix for the Laplacian</a><a id="Towards-the-Stiffness-Matrix-for-the-Laplacian-1"></a><a class="docs-heading-anchor-permalink" href="#Towards-the-Stiffness-Matrix-for-the-Laplacian" title="Permalink"></a></h3><p>Recall that the stiffness matrix for the Laplacian is defined as</p><p class="math-container">\[L_{i,j} = \int_{\Omega} D \Phi_i(x) \cdot D \Phi_j(x)\, dx =
\int_{\Omega} D \Phi_i \cdot D \Phi_j\, dx.\]</p><p>Following the same argumentation as for the mass matrix, the stiffness matrix can be computed by</p><p class="math-container">\[L_{n(k,l), n(k,h)} \gets L_{n(k,l), n(k,h)} +
\int_{T} (D \phi_l J_k^{-1}) \cdot (D \phi_h J_k^{-1})\,
\vert \mathrm{det}(J_k)\vert\, dx\\ \forall\, (k,h,l) \in
\lbrace1,\dots,K\rbrace\times \lbrace 1,2,3 \rbrace^2.\]</p><p>The general structure of a code, which assembles stiffness or mass matrix, is based on three nested loops. The outermost loop iterates over all triangles, then one loop over three basis functions and the innermost loop iterates over three test functions.</p><h3 id="Example-Calculation-for-the-Stiffness-Matrix"><a class="docs-heading-anchor" href="#Example-Calculation-for-the-Stiffness-Matrix">Example Calculation for the Stiffness Matrix</a><a id="Example-Calculation-for-the-Stiffness-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Calculation-for-the-Stiffness-Matrix" title="Permalink"></a></h3><p>Consider the following domain as <span>$\Omega$</span></p><p><img src="../assets/fem/simple_grid.svg" alt="Simple Grid"/></p><p>As an example we assume piece-wise linear basis functions and compute one entry of the stiffness matrix of the Laplacian</p><p class="math-container">\[L_{1,3} = \int_\Omega D \Phi_1 \cdot D \Phi_3\, dx\]</p><p>which corresponds to the basis function <span>$\Phi_1$</span> located in <span>$w_1$</span> and <span>$\Phi_3$</span> in <span>$w_3$</span>.</p><p>Inspecting the support of <span>$D \Phi_1 \cdot D \Phi_3$</span> we see that</p><p class="math-container">\[L_{1,3} = \int_{T_1} D \Phi_1 \cdot D \Phi_3\, dx + \int_{T_4} D \Phi_1 \cdot D \Phi_3\, dx.\]</p><p>Let the transformation function for <span>$T_1$</span> be given by <span>$\psi_1: T \to T_1$</span> such that <span>$\psi_1(v_1) = w_1, \psi_1(v_2) = w_2, \psi_3(v_3) = w_3$</span> as sketched below</p><p><img src="../assets/fem/mapping.svg" alt="Element Mapping"/></p><p>Thus, we obtain</p><p class="math-container">\[\Psi_1(v) = J_1 v + w_1, \quad J_1 = [w_2 - w_1 \vert w_3 - w_1] =
\begin{pmatrix} a &amp; \frac{a}{2}\\ 0 &amp; \frac{b}{2} \end{pmatrix}.\]</p><p>For the triangle <span>$T_4$</span> we obtain similarly by choosing  <span>$\psi_4(v_1) = w_4, \psi_4(v_2) = w_1, \psi_4(v_3) = w_3$</span> that</p><p class="math-container">\[\Psi_4(v) = J_4 v + w_4, \quad J_4 = [w_1 - w_4 \vert w_3 - w_4] =
\begin{pmatrix} 0 &amp; \frac{a}{2}\\ -b &amp; -\frac{b}{2} \end{pmatrix}.\]</p><p>Recall the mapping <span>$\eta(l,i) \in \lbrace 1,2,3 \rbrace$</span> which assigns the global node number <span>$i$</span> to the local node number <span>$\eta(l,i)$</span> in the <span>$l$</span>-th triangle. Using this notation we obtain <span>$\eta(1,3) = 3, \eta(1,1) = 1$</span> and <span>$\eta(4,3) = 3, \eta(4,1) = 2$</span>. Further, recall that local basis functions <span>$\phi_n: T \to \mathbb{R}$</span> are chosen as</p><p class="math-container">\[\phi_n (v_j) = \delta_{nj}, \quad 1\leq n,j \leq 3\]</p><p>such that we obtain</p><p class="math-container">\[D \phi_1 = (-1,-1),\; D \phi_2 = (1,0),\; D \phi_3 = (0,1).\]</p><p>We also compute</p><p class="math-container">\[J_1^{-1} = \frac{2}{ab} \begin{pmatrix} \frac{b}{2} &amp; -\frac{a}{2}\\ 0 &amp; a \end{pmatrix}
\quad \text{and} \quad \mathrm{det}(J_1) = \frac{ab}{2}\]</p><p class="math-container">\[J_4^{-1} = \frac{2}{ab} \begin{pmatrix} -\frac{b}{2} &amp; -\frac{a}{2}\\ b &amp; 0 \end{pmatrix}
\quad \text{and} \quad \mathrm{det}(J_4) = \frac{ab}{2}.\]</p><p>We can thus conclude</p><p class="math-container">\[\int_{T_1} D \Phi_1 \cdot D \Phi_3\, dx = \int_{T} (D \phi_1  J^{-1}_1) \cdot
(D \phi_3 J^{-1}_1)\, \vert \mathrm{det}(J_1)\vert dx = - \frac{a}{2b}\]</p><p>and</p><p class="math-container">\[\int_{T_4} D \Phi_1 \cdot D \Phi_3\, dx = \int_{T} (D \phi_2 J^{-1}_4) \cdot
(D \phi_3 J^{-1}_4)\, \vert \mathrm{det}(J_4)\vert dx = - \frac{b}{2a}\]</p><p>which results in </p><p class="math-container">\[L_{1,3} = \int_{T_1} D \Phi_1 \cdot D \Phi_3\, dx + \int_{T_4} D \Phi_1 \cdot
D \Phi_3\, dx = - \frac{a}{2b} - \frac{b}{2a}.\]</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../gettingstarted/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 15 June 2023 12:32">Thursday 15 June 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
