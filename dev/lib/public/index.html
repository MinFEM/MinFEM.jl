<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · MinFEM.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MinFEM.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MinFEM.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../fem/">The Finite Element Method</a></li><li><a class="tocitem" href="../../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../../paraview/">Visualization</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/poisson/">A Poisson Problem</a></li><li><a class="tocitem" href="../../examples/boundary_source/">A Boundary Source Problem</a></li><li><a class="tocitem" href="../../examples/elasticity/">A Vector-Valued Problem</a></li><li><a class="tocitem" href="../../examples/semilinear/">A Semi-Linear Problem</a></li><li><a class="tocitem" href="../../examples/parabolic/">A Time-Dependent Problem</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Module"><span>Module</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions-and-Methods"><span>Functions and Methods</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal</a></li></ul></li><li><a class="tocitem" href="../../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MinFEM/MinFEM.jl/blob/master/docs/src/lib/public.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><hr/><p>Documentation for <code>MinFEM.jl</code>&#39;s public interface.</p><p>See the <a href="../internal/">Internal</a> page of the library for the documentation  of internal types and functions.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation">Public Documentation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Module">Module</a></li><li><a href="#Types">Types</a></li><li><a href="#Functions-and-Methods">Functions and Methods</a></li><li class="no-marker"><ul><li><a href="#Mesh-Generation">Mesh Generation</a></li><li><a href="#Type-Handling">Type Handling</a></li><li><a href="#Function-Discretization">Function Discretization</a></li><li><a href="#Mesh-(Element)-Properties">Mesh (Element) Properties</a></li><li><a href="#Local-Quadrature">Local Quadrature</a></li><li><a href="#Vector-Valued-Coefficients-Handling">Vector-Valued Coefficients Handling</a></li><li><a href="#Weight-Computation">Weight Computation</a></li><li><a href="#Finite-Element-Basis-Functions">Finite Element Basis Functions</a></li><li><a href="#FE-Operator-Assembly">FE Operator Assembly</a></li><li><a href="#Boundary-Condition-Handling">Boundary Condition Handling</a></li><li><a href="#FE-Extensions">FE Extensions</a></li><li><a href="#PDE-System-Handling">PDE System Handling</a></li><li><a href="#Output">Output</a></li></ul></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Module"><a class="docs-heading-anchor" href="#Module">Module</a><a id="Module-1"></a><a class="docs-heading-anchor-permalink" href="#Module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MinFEM.MinFEM" href="#MinFEM.MinFEM"><code>MinFEM.MinFEM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MinFEM</code></pre><p>A minimal finite element tool for demonstration and teaching in julia.</p><p>This package imports the following packages:</p><ul><li><code>Base</code></li><li><code>Core</code></li><li><code>DocStringExtensions</code></li><li><code>LinearAlgebra</code></li><li><code>SparseArrays</code></li><li><code>WriteVTK</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/MinFEM.jl#L1-L8">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MinFEM.Mesh" href="#MinFEM.Mesh"><code>MinFEM.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Mesh</code></pre><p>Type for a triangular finite element mesh with volume and boundary markers.</p><p><strong>Fields</strong></p><ul><li><p><code>d::Int64</code>: Spatial dimension</p></li><li><p><code>nnodes::Int64</code>: Number of nodes</p></li><li><p><code>nelems::Int64</code>: Number of elements</p></li><li><p><code>nboundelems::Int64</code>: Number of physical (marked) boundary elements</p></li><li><p><code>Nodes::Vector{Vector{Float64}}</code>: List of node coordinates</p></li><li><p><code>Elements::Vector{Vector{Int64}}</code>: List of element node indices</p></li><li><p><code>BoundaryElements::Vector{Vector{Int64}}</code>: List of boundary element node indices</p></li><li><p><code>ParentElements::Vector{Int64}</code>: List of parent elements to boundary elements</p></li><li><p><code>ParentBoundaries::Vector{Int64}</code>: List of parent element local boundary to boundary elements</p></li><li><p><code>Boundaries::Dict{Int64, Boundary}</code>: Dictionary of marked boundaries</p></li><li><p><code>Domains::Dict{Int64, Domain}</code>: Dictionary of marked volume regions</p></li><li><p><code>Entities::Vector{Dict{Int64, MinFEM.Entity}}</code>: Dictionary of physical entities</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.Region" href="#MinFEM.Region"><code>MinFEM.Region</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type Region</code></pre><p>Abstract supertype for structs specifing regions of a domain, i.e. mesh. Subtypes should contain at least Name, Nodes and Elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.Boundary" href="#MinFEM.Boundary"><code>MinFEM.Boundary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Boundary &lt;: MinFEM.Region</code></pre><p>Structure holding the name and sets of node and edge indices for one particular physical boundary.</p><p><strong>Fields</strong></p><ul><li><p><code>Name::String</code>: Unique physical name</p></li><li><p><code>Nodes::Set{Int64}</code>: List of node indices</p></li><li><p><code>Elements::Set{Int64}</code>: List of element indices</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.Domain" href="#MinFEM.Domain"><code>MinFEM.Domain</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct Domain &lt;: MinFEM.Region</code></pre><p>Type holding the name and the set of element indices for one particular physical domain.</p><p><strong>Fields</strong></p><ul><li><p><code>Name::String</code>: Unique physical name</p></li><li><p><code>Nodes::Set{Int64}</code>: List of node indices</p></li><li><p><code>Elements::Set{Int64}</code>: List of element indices</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.PDESystem" href="#MinFEM.PDESystem"><code>MinFEM.PDESystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PDESystem</code></pre><p>Structure holding all information to describe simple PDEs  with Dirichlet boundary conditions.</p><p><strong>Fields</strong></p><ul><li><p><code>A::SparseArrays.SparseMatrixCSC{Float64, Int64}</code>: Stiffness matrix</p></li><li><p><code>b::Vector{Float64}</code>: Load vector</p></li><li><p><code>bc::Vector{Float64}</code>: Dirichlet boundary values</p></li><li><p><code>DI::Set{Int64}</code>: Dirichlet nodes</p></li><li><p><code>qdim::Int64</code>: Components of vector-valued state</p></li><li><p><code>Factors::Any</code>: System matrix factorization</p></li><li><p><code>SystemMatrix::SparseArrays.SparseMatrixCSC{Float64, Int64}</code>: System of stiffness matrix and Dirichlet conditinons</p></li><li><p><code>B::SparseArrays.SparseMatrixCSC{Float64, Int64}</code>: Dirichlet projection matrix</p></li><li><p><code>state::Vector{Float64}</code>: Solution vector</p></li><li><p><code>rhs::Vector{Float64}</code>: Right hand side vector with source term and dirichlet conditions</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/pdesystem.jl#L1">source</a></section></article><h2 id="Functions-and-Methods"><a class="docs-heading-anchor" href="#Functions-and-Methods">Functions and Methods</a><a id="Functions-and-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-Methods" title="Permalink"></a></h2><h3 id="Mesh-Generation"><a class="docs-heading-anchor" href="#Mesh-Generation">Mesh Generation</a><a id="Mesh-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-Generation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.unit_interval" href="#MinFEM.unit_interval"><code>MinFEM.unit_interval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_interval(n::Int64) -&gt; Mesh
</code></pre><p>Returns an n nodes quasi-uniform mesh for the 1D unit interval. The left boundary node is denoted by 1001 and the right one by 1002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.unit_square" href="#MinFEM.unit_square"><code>MinFEM.unit_square</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unit_square(n::Int64) -&gt; Mesh
</code></pre><p>Returns a n-by-n quasi-uniform mesh for the 2D unit square. The boundary indices are given in the order bottom, top, left, right from 1001 to 1004.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.import_mesh" href="#MinFEM.import_mesh"><code>MinFEM.import_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">import_mesh(fileName::String) -&gt; Mesh
</code></pre><p>Returns a mesh imported from a gmsh file of version v1, v2 or v4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.export_mesh" href="#MinFEM.export_mesh"><code>MinFEM.export_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">export_mesh(mesh::Mesh, fileName::String)
</code></pre><p>Exports a mesh to a gmsh file of version v2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.update_mesh!" href="#MinFEM.update_mesh!"><code>MinFEM.update_mesh!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_mesh!(
    mesh::Mesh,
    c::Vector{Vector{Float64}}
) -&gt; Vector{Vector{Float64}}
</code></pre><p>Updates given mesh by shifting all nodes to new coordinates c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.deform_mesh!" href="#MinFEM.deform_mesh!"><code>MinFEM.deform_mesh!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_mesh!(mesh::Mesh, v::AbstractVector{Float64}; t::Float64=1.0)</code></pre><p>Deforms given mesh by shifting all nodes according to the vector field v  scaled by the stepsize t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1008-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.deform_mesh" href="#MinFEM.deform_mesh"><code>MinFEM.deform_mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deform_mesh(mesh::Mesh, v::AbstractVector{Float64}; t::Float64=1.0) -&gt; Mesh</code></pre><p>Returns copy of mesh deformed by <code>deform_mesh!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1024-L1028">source</a></section></article><h3 id="Type-Handling"><a class="docs-heading-anchor" href="#Type-Handling">Type Handling</a><a id="Type-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Handling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.select_boundaries" href="#MinFEM.select_boundaries"><code>MinFEM.select_boundaries</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_boundaries(mesh::Mesh, args...) -&gt; Set{Boundary}
</code></pre><p>Returns set of all or specified physical boundaries of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.select_domains" href="#MinFEM.select_domains"><code>MinFEM.select_domains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">select_domains(mesh::Mesh, args...) -&gt; Set{Domain}
</code></pre><p>Returns set of all or specified physical boundaries of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1060-L1064">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.extract_elements" href="#MinFEM.extract_elements"><code>MinFEM.extract_elements</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_elements(boundaries::Set{Boundary}) -&gt; Set{Int64}
</code></pre><p>Returns set of boundary element ids in set of physical boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1111">source</a></section><section><div><pre><code class="language-julia hljs">extract_elements(domains::Set{Domain}) -&gt; Set{Int64}
</code></pre><p>Returns set of boundary element ids in set of physical domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.extract_nodes" href="#MinFEM.extract_nodes"><code>MinFEM.extract_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">extract_nodes(boundaries::Set{Boundary}) -&gt; Set{Int64}
</code></pre><p>Returns set of node ids in set of physical boundaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1085">source</a></section><section><div><pre><code class="language-julia hljs">extract_nodes(domains::Set{Domain}) -&gt; Set{Int64}
</code></pre><p>Returns set of node ids in set of physical domains.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1098">source</a></section></article><h3 id="Function-Discretization"><a class="docs-heading-anchor" href="#Function-Discretization">Function Discretization</a><a id="Function-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Discretization" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.evaluate_mesh_function" href="#MinFEM.evaluate_mesh_function"><code>MinFEM.evaluate_mesh_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_mesh_function(
    mesh::Mesh,
    f::Function,
    region::Set{Boundary};
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Returns evaluation of a given function object f on all or specified nodes of the mesh. Can be either called with set of physical boundaries or directly with a set of nodes  when given with keyword argument region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1137-L1148">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate_mesh_function(
    mesh::Mesh,
    f::Function,
    region::Set{Boundary};
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Same as previous evaluate<em>mesh</em>function(...) but takes <code>Set{Boundary}</code> as mandatory argument for the relevant region, which replaces the keyword argument using <code>Set{Int64}</code>. Extracts nodes from the boundary and then passes them to the base function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1175-L1186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.evaluate_function" href="#MinFEM.evaluate_function"><code>MinFEM.evaluate_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_function(
    f::Vector{Float64},
    node::Int64;
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Evaluates discrete function give as FEM coefficient vector at a given node. Resulting vector has the lenght of the number of components of f. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1196-L1205">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate_function(
    f::Vector{Float64},
    region::Set{Int64};
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Evaluates discrete function give as FEM coefficient vector at all nodes in a given region. Resulting vector has the lenght of the full coefficient vector with the entries corresponding to non-evaluated nodes being zero. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1214-L1224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.evaluate_quadrature_function" href="#MinFEM.evaluate_quadrature_function"><code>MinFEM.evaluate_quadrature_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_quadrature_function(
    mesh::Mesh,
    f::Function;
    region::Set{Int64} = Set{Int64}(),
    order::Int64 = 1, 
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Returns vector of function f evaluated at each elements quadrature points  of the given mesh for the specified order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L509-L520">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate_quadrature_function(
    mesh::Mesh,
    f::Function,
    region::Set{Domain};
    order::Int64 = 1, 
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Same as previous evaluate<em>quadrature</em>function(...) but takes <code>Set{Domain}</code> as mandatory argument for the relevant region, which replaces the keyword argument using <code>Set{Int64}</code>. Extracts nodes from the domain and then passes them to the base function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L560-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.evaluate_quadrature_function_boundary" href="#MinFEM.evaluate_quadrature_function_boundary"><code>MinFEM.evaluate_quadrature_function_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_quadrature_boundary(
    mesh::Mesh,
    f::Function;
    region::Set{Int64} = Set{Int64}(),
    order::Int64 = 1, 
    qdim::Int64 = 1 
) -&gt; Vector{Float64}</code></pre><p>Returns vector of function f with qdim components evaluated at each or specified boundary elements quadrature points of the given mesh for the specified order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L589-L600">source</a></section><section><div><pre><code class="nohighlight hljs">evaluate_quadrature_function_boundary(
    mesh::Mesh,
    f::Function,
    region::Set{Boundary};
    order::Int64 = 1, 
    qdim::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Same as previous evaluate<em>quadrature</em>function_boundary(...) but takes <code>Set{Boundary}</code> as mandatory argument for the relevant region, which replaces the keyword argument using <code>Set{Int64}</code>. Extracts elements from the boundary and then passes them to the base function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L640-L652">source</a></section></article><h3 id="Mesh-(Element)-Properties"><a class="docs-heading-anchor" href="#Mesh-(Element)-Properties">Mesh (Element) Properties</a><a id="Mesh-(Element)-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-(Element)-Properties" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.jacobian" href="#MinFEM.jacobian"><code>MinFEM.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian(
    coords::Vector{Vector{Float64}}
) -&gt; Tuple{Float64, LinearAlgebra.Adjoint{Float64, Matrix{Float64}}}
</code></pre><p>Returns determinant (i.e. element weight) and inverse transposed of the jacobian  of an FEM element spanned by nodes at the given coordinates.</p><p>Commonly the coordinates correspond to one element in a mesh, but not necessarily have to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1282">source</a></section><section><div><pre><code class="language-julia hljs">jacobian(
    mesh::Mesh,
    nodes::Vector{Int64}
) -&gt; Tuple{Float64, LinearAlgebra.Adjoint{Float64, Matrix{Float64}}}
</code></pre><p>Same as previous <code>jacobian(...)</code>, but takes a mesh and set of nodes as arguments. Extracts coordinates from the mesh and passes them to the base function.</p><p>Commonly the coordinates correspond to one element in a mesh, but not necessarily have to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1297">source</a></section><section><div><pre><code class="language-julia hljs">jacobian(
    mesh::Mesh,
    element::Int64
) -&gt; Tuple{Float64, LinearAlgebra.Adjoint{Float64, Matrix{Float64}}}
</code></pre><p>Same as previous <code>jacobian(...)</code>, but takes a mesh and an element id as arguments. Extracts coordinates of the support nodes from the mesh and passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.jacobian_boundary" href="#MinFEM.jacobian_boundary"><code>MinFEM.jacobian_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobian_boundary(
    coords::Vector{Vector{Float64}}
) -&gt; Union{Nothing, Float64, Int64}
</code></pre><p>Returns determinant of the jacobian (i.e. element weight) of an FEM boundary element (in d-1 dimensions) spanned spanned by nodes at the given coordinates.</p><p>Commonly the coordinates correspond to an element in a mesh, but not necessarily have to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1320">source</a></section><section><div><pre><code class="language-julia hljs">jacobian_boundary(
    mesh::Mesh,
    nodes::Vector{Int64}
) -&gt; Union{Nothing, Float64, Int64}
</code></pre><p>Same as previous <code>jacobian_boundary(...)</code>, but takes a mesh and set of nodes as arguments. Extracts coordinates from the mesh and passes them to the base function.</p><p>Commonly the coordinates correspond to one element in a mesh, but not necessarily have to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1340">source</a></section><section><div><pre><code class="language-julia hljs">jacobian_boundary(
    mesh::Mesh,
    element::Int64
) -&gt; Union{Nothing, Float64, Int64}
</code></pre><p>Same as previous <code>jacobian_boundary(...)</code>, but takes a mesh and an element id as arguments. Extracts coordinates of the support nodes from the mesh and passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementvolume" href="#MinFEM.elementvolume"><code>MinFEM.elementvolume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementvolume(d::Int64) -&gt; Float64
</code></pre><p>Returns volume of the d-dimensional reference element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1363">source</a></section><section><div><pre><code class="language-julia hljs">elementvolume(mesh::Mesh, element::Int64) -&gt; Float64
</code></pre><p>Returns volume of the given element in the given mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1372">source</a></section><section><div><pre><code class="language-julia hljs">elementvolume(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Returns vector of volumes of all elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementvolume_boundary" href="#MinFEM.elementvolume_boundary"><code>MinFEM.elementvolume_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementvolume_boundary(d::Int64) -&gt; Float64
</code></pre><p>Returns volume of the (d-1)-dimensional boundary reference element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1399">source</a></section><section><div><pre><code class="language-julia hljs">elementvolume_boundary(
    mesh::Mesh,
    element::Int64
) -&gt; Float64
</code></pre><p>Returns volume of the given boundary element in the given mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1408">source</a></section><section><div><pre><code class="language-julia hljs">elementvolume_boundary(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Returns vector of volumes of all boundary elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1418">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementbarycenter" href="#MinFEM.elementbarycenter"><code>MinFEM.elementbarycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementbarycenter(d::Int64) -&gt; Vector{Float64}
</code></pre><p>Returns barycenter vector of the d-dimensional reference element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1435">source</a></section><section><div><pre><code class="language-julia hljs">elementbarycenter(
    mesh::Mesh,
    element::Int64
) -&gt; Vector{Float64}
</code></pre><p>Returns barycenter of the given element in the given mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1447">source</a></section><section><div><pre><code class="language-julia hljs">elementbarycenter(mesh::Mesh) -&gt; Vector{Vector{Float64}}
</code></pre><p>Returns vector of all barycenters of all element in the given mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementdiameter" href="#MinFEM.elementdiameter"><code>MinFEM.elementdiameter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementdiameter(
    coords::Vector{Vector{Float64}}
) -&gt; Union{Float64, Int64}
</code></pre><p>Returns diameter (i.e. longest edge length) of an element spanned by nodes at the given coordinates.</p><p>The coordinates do not necessarily have to span an element of full dimension. Could also be used for boundary elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1476">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter(
    mesh::Mesh,
    nodes::Vector{Int64}
) -&gt; Union{Float64, Int64}
</code></pre><p>Same as previous <code>elementdiameter(...)</code>, but takes a mesh and set of nodes as arguments. Extracts coordinates from the mesh and passes them to the base function.</p><p>Commonly the coordinates correspond to one (boundary) element in a mesh, but not necessarily have to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1499">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter(
    mesh::Mesh,
    element::Int64
) -&gt; Union{Float64, Int64}
</code></pre><p>Same as previous <code>elementdiameter(...)</code>, but takes a mesh and an element id as arguments. Extracts coordinates of the support nodes from the mesh and passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1512">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Similar ot previous <code>elementdiameter(...)</code>, but returns vector of elementdiameters for all  elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementdiameter_boundary" href="#MinFEM.elementdiameter_boundary"><code>MinFEM.elementdiameter_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementdiameter_boundary(
    coords::Vector{Vector{Float64}}
) -&gt; Union{Float64, Int64}
</code></pre><p>Returns diameter (i.e. longest edge length) of a boundary element spanned by nodes at the given coordinates.</p><p>Commonly the coordinates correspond to one boundary element in a mesh, but not necessarily have to.</p><p>Since the number of nodes to span an element is not prescribed, the functionality is identical to <code>elementdiameter(args)</code>. However this function is kept for consistency and improved readability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1539">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter_boundary(
    mesh::Mesh,
    nodes::Vector{Int64}
) -&gt; Union{Float64, Int64}
</code></pre><p>Same as previous <code>elementdiameter_boundary(...)</code>, but takes a mesh and set of nodes as arguments. Extracts coordinates from the mesh and passes them to the base function.</p><p>Commonly the coordinates correspond to one (boundary) element in a mesh, but not necessarily have to.</p><p>Since the number of nodes to span an element is not prescribed, the functionality is identical to <code>elementdiameter(args)</code>. However this function is kept for consistency and improved readability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1556">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter_boundary(
    mesh::Mesh,
    element::Int64
) -&gt; Union{Float64, Int64}
</code></pre><p>Same as previous <code>elementdiameter_boundary(...)</code>, but takes a mesh and a boundary element id as arguments. Extracts coordinates of the support nodes from the mesh and passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1573">source</a></section><section><div><pre><code class="language-julia hljs">elementdiameter_boundary(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Similar ot previous <code>elementdiameter_boundary(...)</code>, but returns vector of elementdiameters for all  elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementratio" href="#MinFEM.elementratio"><code>MinFEM.elementratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementratio(
    coords::Vector{Vector{Float64}}
) -&gt; Union{Float64, Int64}
</code></pre><p>Returns ratio of inscribed to circumscribed circle or sphere for an element spanned by nodes at the given coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1620">source</a></section><section><div><pre><code class="language-julia hljs">elementratio(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Same as previous <code>elementratio(...)</code>, but returns vector of ratios for all elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1637">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.elementangle" href="#MinFEM.elementangle"><code>MinFEM.elementangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementangle(
    coords::Vector{Vector{Float64}}
) -&gt; Union{Irrational{:π}, Float64}
</code></pre><p>Returns smallest interior angle for an element spanned by nodes at the given coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1652">source</a></section><section><div><pre><code class="language-julia hljs">elementangle(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Same as previous <code>elementangle(...)</code>, but returns vector of angles for all elements in the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.outernormalvector" href="#MinFEM.outernormalvector"><code>MinFEM.outernormalvector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outernormalvector(dim::Int64, ii::Int64) -&gt; Vector{Float64}
</code></pre><p>Returns the outer normal vector at the ii-th boundary of the dim-dimensional reference element. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1699">source</a></section><section><div><pre><code class="language-julia hljs">outernormalvector(
    mesh::Mesh,
    boundaryElement::Int64,
    J::AbstractMatrix{Float64}
) -&gt; Any
</code></pre><p>Returns the outer normal vector at a boundary element of the given mesh using a pre-computed jacobian transformation matrix of the parent element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1718">source</a></section><section><div><pre><code class="language-julia hljs">outernormalvector(
    mesh::Mesh,
    boundaryElement::Int64
) -&gt; Vector{Float64}
</code></pre><p>Returns the outer normal vector at the given boundary element of the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1737">source</a></section><section><div><pre><code class="nohighlight hljs">outernormalvector(
    mesh::Mesh;
    boundaryElements::Set{Int64} = Set{Int64}()
) -&gt; Vector{Float64}</code></pre><p>Returns coefficient vector of outer normal vectors at all or specified boundary elements of the given mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1750-L1758">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.stripwidth" href="#MinFEM.stripwidth"><code>MinFEM.stripwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stripwidth(mesh::Mesh) -&gt; Any
</code></pre><p>Return width L of a strip that the meshed domain fits into.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1818">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.boundingbox" href="#MinFEM.boundingbox"><code>MinFEM.boundingbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boundingbox(mesh::Mesh) -&gt; Vector{Array}
</code></pre><p>Return two nodes which span the bounding box of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.volume" href="#MinFEM.volume"><code>MinFEM.volume</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">volume(mesh::Mesh) -&gt; Union{Float64, Int64}
</code></pre><p>Returns the d-dimenional volume of the domain definded by the mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1776">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.barycenter" href="#MinFEM.barycenter"><code>MinFEM.barycenter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">barycenter(mesh::Mesh) -&gt; Vector{Float64}
</code></pre><p>Returns the d-dimenional domain of the domain definded by the mesh. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/mesh.jl#L1793">source</a></section></article><h3 id="Local-Quadrature"><a class="docs-heading-anchor" href="#Local-Quadrature">Local Quadrature</a><a id="Local-Quadrature-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Quadrature" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.quadrature_points" href="#MinFEM.quadrature_points"><code>MinFEM.quadrature_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadrature_points(
    d::Int64,
    order::Int64
) -&gt; Union{Nothing, Vector{Vector{Float64}}}
</code></pre><p>Returns coordinates of the Gauss-Legendre quadrature points  on the d-dimensional FEM reference element  for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L254">source</a></section><section><div><pre><code class="language-julia hljs">quadrature_points(
    mesh::Mesh,
    order::Int64
) -&gt; Vector{Vector{Float64}}
</code></pre><p>Returns global coordinates of the Gauss-Legendre quadrature points  on each finite element in the given mesh for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L301">source</a></section><section><div><pre><code class="language-julia hljs">quadrature_points(
    element::Int64,
    mesh::Mesh,
    order::Int64
) -&gt; Vector{Vector{Float64}}
</code></pre><p>Returns global coordinates of the Gauss-Legendre quadrature points  on a specified element in the given mesh for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.quadrature_points_boundary" href="#MinFEM.quadrature_points_boundary"><code>MinFEM.quadrature_points_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadrature_points_boundary(
    d::Int64,
    order::Int64
) -&gt; Union{Nothing, Vector{Vector{Float64}}}
</code></pre><p>Returns coordinates of the Gauss-Legendre quadrature points  on the (d-1)-dimensional FEM reference element  for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L347">source</a></section><section><div><pre><code class="nohighlight hljs">quadrature_points_boundary(
    mesh::Mesh,
    order::Int64;
    boundaryElements::Set{Int64} = Set{Int64}()
)-&gt; Array{Array{Float64,1},1}</code></pre><p>Returns global coordinates of the Gauss-Legendre quadrature points  on each boundary element in the given mesh for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L358-L368">source</a></section><section><div><pre><code class="language-julia hljs">quadrature_points_boundary(
    element::Int64,
    mesh::Mesh,
    order::Int64
) -&gt; Vector{Vector{Float64}}
</code></pre><p>Returns global coordinates of the Gauss-Legendre quadrature points  on a specified boundary element in the given mesh for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.quadrature_weights" href="#MinFEM.quadrature_weights"><code>MinFEM.quadrature_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadrature_weights(
    d::Int64,
    order::Int64
) -&gt; Union{Nothing, Vector{Float64}}
</code></pre><p>Returns weights of the Gauss-Legendre quadrature points  on the d-dimensional FEM reference element  for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.quadrature_weights_boundary" href="#MinFEM.quadrature_weights_boundary"><code>MinFEM.quadrature_weights_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadrature_weights_boundary(
    d::Int64,
    order::Int64
) -&gt; Union{Nothing, Vector{Float64}}
</code></pre><p>Returns weights of the Gauss-Legendre quadrature points  on the (d-1)-dimensional FEM reference element  for exact integration of polynomials up to the given order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.quadrature_order" href="#MinFEM.quadrature_order"><code>MinFEM.quadrature_order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quadrature_order(d::Int64, n::Int64) -&gt; Int64
</code></pre><p>Returns highest quadrature order archived by using n points in d dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.integral_over_reference_element" href="#MinFEM.integral_over_reference_element"><code>MinFEM.integral_over_reference_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integral_over_reference_element(
    f::Function,
    d::Int64;
    order::Int64 = 1
) -&gt; Float64</code></pre><p>Returns integral of function f over the d-dimensional FEM reference element  computed with Gauss-Legendre quadrature exact at least for polynomials up to given order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/quadrature.jl#L488-L497">source</a></section></article><h3 id="Vector-Valued-Coefficients-Handling"><a class="docs-heading-anchor" href="#Vector-Valued-Coefficients-Handling">Vector-Valued Coefficients Handling</a><a id="Vector-Valued-Coefficients-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Valued-Coefficients-Handling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.prolong_multivector" href="#MinFEM.prolong_multivector"><code>MinFEM.prolong_multivector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prolong_multivector(
    x::AbstractVector{Float64},
    m::Int64,
    qdim::Int64; 
    block::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Prolongates a vector of m blocks of size block to a multivector  for qdim components of length qdim×block×m.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.restrict_multivector" href="#MinFEM.restrict_multivector"><code>MinFEM.restrict_multivector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">restrict_multivector(
    x::AbstractVector{Float64},
    m::Int64,
    qdim::Int64;
    block::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Restricts a multivector of qdim×block×m elements for qdim components  to the regular vector of m blocks of size block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L31-L41">source</a></section></article><h3 id="Weight-Computation"><a class="docs-heading-anchor" href="#Weight-Computation">Weight Computation</a><a id="Weight-Computation-1"></a><a class="docs-heading-anchor-permalink" href="#Weight-Computation" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_weightmultivector" href="#MinFEM.assemble_weightmultivector"><code>MinFEM.assemble_weightmultivector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_weightmultivector(
    mesh::Mesh;
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Returns the vector of weights for all elements of mesh and qdim components. Weight is equal to volume if 1st order integration by mid-point rule is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L105-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_weightmultivector_boundary" href="#MinFEM.assemble_weightmultivector_boundary"><code>MinFEM.assemble_weightmultivector_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_weightmultivector_boundary(
    mesh::Mesh;
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Vector{Float64}</code></pre><p>Returns the vector of weights for all boundary elements of mesh and qdim components. Weight is equal to volume if 1st order integration by mid-point rule is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L133-L142">source</a></section></article><h3 id="Finite-Element-Basis-Functions"><a class="docs-heading-anchor" href="#Finite-Element-Basis-Functions">Finite Element Basis Functions</a><a id="Finite-Element-Basis-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-Element-Basis-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.phi" href="#MinFEM.phi"><code>MinFEM.phi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phi(ii::Int64, x::AbstractVector{T} where T) -&gt; Any
</code></pre><p>Returns ii-th local basis function evaluated at x.  Dimension is determined by length(x). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.grad_phi" href="#MinFEM.grad_phi"><code>MinFEM.grad_phi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grad_phi(d::Int64, ii::Int64) -&gt; Matrix{Float64}
</code></pre><p>Gradient of ii-th local basis functions in d dimensions. Note that the gradient is constant on an element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L15">source</a></section></article><h3 id="FE-Operator-Assembly"><a class="docs-heading-anchor" href="#FE-Operator-Assembly">FE Operator Assembly</a><a id="FE-Operator-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#FE-Operator-Assembly" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_derivativematrix" href="#MinFEM.assemble_derivativematrix"><code>MinFEM.assemble_derivativematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_derivativematrix(mesh::Mesh; qdim::Int64=1) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the discrete derivative matrix for all elements of mesh and qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_laplacian" href="#MinFEM.assemble_laplacian"><code>MinFEM.assemble_laplacian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_laplacian(
    mesh::Mesh;
    qdim::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the Laplacian stiffness matrix for all elements of mesh and qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L199-L206">source</a></section><section><div><pre><code class="nohighlight hljs">assemble_laplacian(
    D::SparseMatrixCSC{Float64, Int64},
    w::AbstractVector{Float64}
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the Laplacian stiffness matrix for all elements of a mesh and qdim components.</p><p>Takes existing derivative matrix D and weight vector w as arguments. Can yield performance benefits compared to direct assembly if D already exists. Note that number of components and quadrature order in D and w have to match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L247-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_derivativematrix_boundary" href="#MinFEM.assemble_derivativematrix_boundary"><code>MinFEM.assemble_derivativematrix_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_derivativematrix_boundary(
    mesh::Mesh; 
    boundaryElements::Set{Int64} = Set{Int64}(), 
    qdim::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the discrete derivative matrix for all or specied boundary elements  of mesh and qdim components.</p><p>The implementation is based on the derivate tensor for the corresponding full element and the fact that the gradient ist constant on the element for linear elements. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_normalderivativematrix" href="#MinFEM.assemble_normalderivativematrix"><code>MinFEM.assemble_normalderivativematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_normalderivativematrix(
    mesh::Mesh;
    boundaryElements::Set{Int64} = Set{Int64}(),
    qdim::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the discrete normal derivative matrix for all or specied boundary elements  of mesh and qdim components.</p><p>The implementation is based on the derivate tensor for the corresponding full element and the fact that the gradient ist constant on the element for linear elements. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L323-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_basismatrix" href="#MinFEM.assemble_basismatrix"><code>MinFEM.assemble_basismatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_basismatrix(
    mesh::Mesh;
    qdim::Int64 = 1,
    order::Int64 = 3
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the discrete basis matrix with given local integration order  for all elements of mesh and qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L376-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_massmatrix" href="#MinFEM.assemble_massmatrix"><code>MinFEM.assemble_massmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_massmatrix(
    mesh::Mesh;
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the mass matrix with given local integration order for all elements  of mesh and qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L425-L434">source</a></section><section><div><pre><code class="language-julia hljs">assemble_massmatrix(
    E::SparseArrays.SparseMatrixCSC{Float64, Int64},
    w::AbstractVector{Float64}
) -&gt; SparseArrays.SparseMatrixCSC{Float64, Int64}
</code></pre><p>Returns the mass matrix with given local integration order for all elements  of mesh and qdim components.</p><p>Takes existing basis matrix E and weight vector w as arguments. Can yield performance benefits compared to direct assembly if E already exists. Note that number of components and quadrature order in E and w have to match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_basismatrix_boundary" href="#MinFEM.assemble_basismatrix_boundary"><code>MinFEM.assemble_basismatrix_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_basismatrix_boundary(
    mesh::Mesh; 
    boundaryElements::Set{Int64} = Set{Int64}(),
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the discrete basis matrix with given local integration order for all or specified boundary elements of mesh and qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L497-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_massmatrix_boundary" href="#MinFEM.assemble_massmatrix_boundary"><code>MinFEM.assemble_massmatrix_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_massmatrix_boundary(
    mesh::Mesh; 
    boundaryElements::Set{Int64} = Set{Int64}(), 
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the mass matrix with given local integration order  for all or specified boundary elements of mesh and image dimension qdim components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L552-L562">source</a></section><section><div><pre><code class="language-julia hljs">assemble_massmatrix_boundary(
    E::SparseArrays.SparseMatrixCSC{Float64, Int64},
    w::AbstractVector{Float64}
) -&gt; SparseArrays.SparseMatrixCSC{Float64, Int64}
</code></pre><p>Returns the mass matrix with given local integration order  for all or specified boundary elements of mesh and image dimension qdim components.</p><p>Takes existing boundary basis matrix E and weight vector w as arguments. Can yield performance benefits compared to direct assembly if E already exists. Note that number of components and quadrature order in E and w have to match.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L608">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_cubicterm" href="#MinFEM.assemble_cubicterm"><code>MinFEM.assemble_cubicterm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_cubicterm(
    mesh::Mesh,
    y::AbstractVector;
    order::Int64 = 3
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the cubic term of the standard semilinear parabolic equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L627-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_cubicderivativematrix" href="#MinFEM.assemble_cubicderivativematrix"><code>MinFEM.assemble_cubicderivativematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_cubicderivativematrix(
    mesh::Mesh,
    y::AbstractVector;
    order::Int64 = 3
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the linearization of the cubic term of the standard semilinear elliptic equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L669-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_cubicsecondderivativematrix" href="#MinFEM.assemble_cubicsecondderivativematrix"><code>MinFEM.assemble_cubicsecondderivativematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_cubicsecondderivativematrix(
    mesh::Mesh,
    y::AbstractVector,
    p::AbstractVector;
    order::Int64 = 3
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the second derivative of the cubic term  of the standard semilinear elliptic equation around the state y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L727-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_elasticity" href="#MinFEM.assemble_elasticity"><code>MinFEM.assemble_elasticity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_elasticity(
    mesh::Mesh,
    lambda::Float64,
    mu::Float64
) -&gt; SparseArrays.SparseMatrixCSC{Float64, Int64}
</code></pre><p>Returns the linear elasticity stiffness matrix with constant coefficients λ and μ  for all elements of mesh and image dimension qdim.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L815">source</a></section></article><h3 id="Boundary-Condition-Handling"><a class="docs-heading-anchor" href="#Boundary-Condition-Handling">Boundary Condition Handling</a><a id="Boundary-Condition-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Condition-Handling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_dirichletcondition!" href="#MinFEM.assemble_dirichletcondition!"><code>MinFEM.assemble_dirichletcondition!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_dirichletcondition!(
    A::SparseMatrixCSC{Float64, Int64},
    DI::Set{Int64}; 
    rhs = [],
    bc = [],
    qdim::Int64 = 1,
    insert = 1.0
)</code></pre><p>Modify a stiffness matrix and a right hand side according to the given Dirichlet conditions.</p><p>DI has to be the set of node indices for which the condition should be active. For vector valued states either DI can be set to each component that should have a Dirichlet condtion or qdim is set, if all components should have the condition. If the rhs shall be updated bc needs to be specified explicitly as well. The value insert is put as diagonal element. Usually you want a 1.0 here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L870-L887">source</a></section><section><div><pre><code class="nohighlight hljs">assemble_dirichletcondition!(
    A::SparseMatrixCSC{Float64, Int64},
    DI::Set{Boundary};
    rhs = [],
    bc = [],
    qdim::Int64 = 1,
    insert = 1.0
)</code></pre><p>Same as previous <code>assemble_dirichletcondition!(...)</code>, but takes <code>Set{Boundary}</code> instead of <code>Set{Int64}</code> as argument for the Dirichlet nodes. Thus extracts the nodes first and then passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L923-L936">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_dirichletcondition_rhs!" href="#MinFEM.assemble_dirichletcondition_rhs!"><code>MinFEM.assemble_dirichletcondition_rhs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_dirichletcondition_rhs!(
    A::SparseMatrixCSC{Float64, Int64},
    rhs::AbstractVector{Float64},
    DI::Set{Int64},
    bc::AbstractVector{Float64};
    qdim::Int64 = 1
)</code></pre><p>Modify a right hand side according to the given Dirichlet conditions. Behaviour is similar to <code>assemble_dirichletcondition!(...)</code> however the system matrix A is not updated. Can be relevant for iterative algorithm, where the system matrix is constant and only the right hand side changes. Then one can store the modified matrix and only assemble the right hand side in every iteration.</p><p>DI has to be the set of node indices for which the condition should be active. For vector valued states either DI can be set to each component that should have a Dirichlet condtion or qdim is set, if all components should have the condition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L955-L973">source</a></section><section><div><pre><code class="nohighlight hljs">assemble_dirichletcondition_rhs!(
    A::SparseMatrixCSC{Float64, Int64},
    rhs::AbstractVector{Float64},
    DI::Set{Boundary},
    bc::AbstractVector{Float64};
    qdim::Int64 = 1
)</code></pre><p>Same as previous <code>assemble_dirichletcondition_rhs!(...)</code>, but takes <code>Set{Boundary}</code> instead of <code>Set{Int64}</code> as argument for the Dirichlet nodes. Thus extracts the nodes first and then passes them to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L998-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble_dirichletprojection" href="#MinFEM.assemble_dirichletprojection"><code>MinFEM.assemble_dirichletprojection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble_dirichletprojection(
    ncoeffs::Int64,
    DI::Set{Int64};
    qdim::Int64 = 1
) -&gt; SparseMatrixCSC{Float64, Int64}</code></pre><p>Returns the projection matrix onto the Dirichlet nodes  where the input ncoeffs is understood as qdim*nnodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/fem.jl#L1027-L1036">source</a></section></article><h3 id="FE-Extensions"><a class="docs-heading-anchor" href="#FE-Extensions">FE Extensions</a><a id="FE-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#FE-Extensions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.pnorm" href="#MinFEM.pnorm"><code>MinFEM.pnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pnorm(
    p::Float64,
    v::AbstractVector{Float64},
    mesh::Mesh; 
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Float64</code></pre><p>Returns <span>$L^p$</span>-norm of a FEM coefficient vector v over the nodes  or quadrature points in the elements on the given mesh. Note that for p=Inf, the values do not get inter- or extrapolated and thus it might not be true maximum over the domain, but only over the given data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.qnorm" href="#MinFEM.qnorm"><code>MinFEM.qnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">qnorm(
    p::Float64,
    v::AbstractVector{Float64},
    mesh::Mesh;
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Float64</code></pre><p>Returns <span>$L^q$</span>-norm of a FEM coefficient vector v over the nodes or quadrature points in the elements on the given mesh with q being the conjugated exponent to p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L63-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.twonorm" href="#MinFEM.twonorm"><code>MinFEM.twonorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">twonorm(
    v::AbstractVector{Float64},
    M::AbstractMatrix{Float64}
) -&gt; Any
</code></pre><p>Implementation of the discrete <span>$L^2$</span>-norm based on a mass matrix. Faster version of pnorm for p=2 by using that direct assembly of mass matrix instead of basis matrices is possible. Can be used for domain or boundary depending on the respective mass matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L205">source</a></section><section><div><pre><code class="nohighlight hljs">twonorm(
    v::AbstractVector{Float64},
    mesh::Mesh; 
    qdim::Int64 = 1,
    order::Int64 = 3
)</code></pre><p>Same as previous twonorm(...), but takes mesh and number of components as arguments. Then assembles the mass matrix and passes it to the base function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L217-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.pnorm_boundary" href="#MinFEM.pnorm_boundary"><code>MinFEM.pnorm_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pnorm_boundary(
    p::Float64,
    v::AbstractVector{Float64},
    mesh::Mesh;
    boundaryElements::Set{Int64} = Set{Int64}(),
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Float64</code></pre><p>Returns <span>$L^p$</span>-norm of a FEM coefficient vector v over the nodes or quadrature points  in the boundary elements on the given mesh. Note that for p=Inf, the values do not get inter- or extrapolated and thus it might not be true maximum over the domain, but only over the given data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L101-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.qnorm_boundary" href="#MinFEM.qnorm_boundary"><code>MinFEM.qnorm_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">qnorm_boundary(
    p::Float64,
    v::AbstractVector{Float64},
    mesh::Mesh;
    boundaryElements::Set{Int64} = Set{Int64}(),
    qdim::Int64 = 1,
    order::Int64 = 1
) -&gt; Float64</code></pre><p>Returns <span>$L^q$</span>-norm of a function f or its FEM coefficient vector v over the nodes or quadrature points in the boundary elements on the given mesh with q being the conjugated exponent to p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L173-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.twonorm_boundary" href="#MinFEM.twonorm_boundary"><code>MinFEM.twonorm_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">twonorm_boundary(
    v::AbstractVector{Float64},
    mesh::Mesh;
    boundaryElements::Set{Int64} = Set{Int64}(),
    qdim::Int64 = 1,
    order::Int64 = 3
)</code></pre><p>Implementation of the discrete <span>$L^2$</span>-norm on the boundary based on a mass matrix. Faster version of pnorm for p=2 by using that direct assembly of mass matrix instead of basis matrices is possible. Assembles boundary mass matrix form mesh, boundary elements and the number of components. Then passes it to the base implementation of <code>twonorm</code>, which can be used for boundary terms as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L239-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.conjugated_exponent" href="#MinFEM.conjugated_exponent"><code>MinFEM.conjugated_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">conjugated_exponent(p::Float64) -&gt; Float64
</code></pre><p>Returns conjugated exponent q to p in the Hölder sense 1/p + 1/q = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/extensions.jl#L86">source</a></section></article><h3 id="PDE-System-Handling"><a class="docs-heading-anchor" href="#PDE-System-Handling">PDE System Handling</a><a id="PDE-System-Handling-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-System-Handling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.solve!" href="#MinFEM.solve!"><code>MinFEM.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(S::PDESystem) -&gt; Any
</code></pre><p>First tries to <a href="lib/@ref">assemble!</a> the system matrix with multipliers for Dirichlet conditions. If the system has already been used before, this step is skipped. This is determined depending on an existing factorization of the system matrix. If the stiffness matrix or Dirichlet conditions have changes,  one should invole <a href="lib/@ref">refresh!</a> first. Finally the system is solved via matrix factorization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/pdesystem.jl#L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.assemble!" href="#MinFEM.assemble!"><code>MinFEM.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    S::PDESystem
) -&gt; Union{Nothing, SuiteSparse.UMFPACK.UmfpackLU{Float64, Int64}}
</code></pre><p>If the system has not been used before, sets up the system matrix  with multipliers for Dirichlet conditions and factorizes it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/pdesystem.jl#L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.refresh!" href="#MinFEM.refresh!"><code>MinFEM.refresh!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">refresh!(
    S::PDESystem
) -&gt; Union{Nothing, SuiteSparse.UMFPACK.UmfpackLU{Float64, Int64}}
</code></pre><p>Recomputes the factorization of the stiffness matrix using <a href="lib/@ref">assemble!</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/pdesystem.jl#L86">source</a></section></article><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MinFEM.write_to_vtk" href="#MinFEM.write_to_vtk"><code>MinFEM.write_to_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_to_vtk(
    x::Vector{Vector{Float64}},
    mesh::Mesh,
    data_names::Array{String}, 
    file_name::String,
    qdim::Array{Int64}
)</code></pre><p>Writes multiple data vectors with corresponding names and qdims to a .vtk-file with the given name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L1-L12">source</a></section><section><div><pre><code class="nohighlight hljs">write_to_vtk(
    x::Vector{Vector{Float64}},
    mesh::Mesh,
    data_names::Array{String}, 
    file_name::String;
    qdim::Int64 = 1
)</code></pre><p>Same as pervious <code>write_to_vtk(...)</code>, but can handles simplification by submitting one qdim for all data vectors if they are the same. If everything is scalar no specification of qdim is required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L56-L68">source</a></section><section><div><pre><code class="nohighlight hljs">write_to_vtk(
    x::Vector{Float64},
    mesh::Mesh,
    data_name::String, 
    file_name::String;
    qdim::Int64 = 1
)</code></pre><p>Same as pervious <code>write_to_vtk(...)</code>, but handles setting for a single data vector with corresponding name and qdim. Forwards them to base implementation as array with one entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L79-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.write_to_vtk_boundary" href="#MinFEM.write_to_vtk_boundary"><code>MinFEM.write_to_vtk_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_to_vtk_boundary(
    x::Vector{Vector{Float64}},
    mesh::Mesh, 
    data_names::Array{String}, 
    file_name::String, 
    qdim::Array{Int64};
    boundary=Set{Boundary}()
)</code></pre><p>Writes multiple data vectors with corresponding names and qdims based on the boundary elements of the mesh to a .vtk-file with the given name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L101-L113">source</a></section><section><div><pre><code class="nohighlight hljs">write_to_vtk_boundary(
    x::Vector{Vector{Float64}},
    mesh::Mesh, 
    data_names::Array{String},
    file_name::String; 
    boundary = Set{Boundary}(),
    qdim::Int64 = 1
)</code></pre><p>Same as pervious <code>write_to_vtk_boundary(...)</code>, but can handles simplification by submitting one qdim for all data vectors if they are the same. If everything is scalar no specification of qdim is required. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L149-L162">source</a></section><section><div><pre><code class="nohighlight hljs">write_to_vtk_boundary(
    x::Vector{Float64},
    mesh::Mesh, 
    data_name::String,
    file_name::String; 
    boundary = Set{Boundary}(),
    qdim::Int64 = 1
)</code></pre><p>Same as pervious <code>write_to_vtk_boundary(...)</code>, but handles setting for a single data vector with corresponding name and qdim. Forwards them to base implementation as array with one entry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L181-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.open_vtkfile" href="#MinFEM.open_vtkfile"><code>MinFEM.open_vtkfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">open_vtkfile(
    mesh::Mesh,
    file_name::String
) -&gt; WriteVTK.DatasetFile
</code></pre><p>Open a new VTK output file and write the mesh data into it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.open_vtkfile_boundary" href="#MinFEM.open_vtkfile_boundary"><code>MinFEM.open_vtkfile_boundary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">open_vtkfile_boundary(
    mesh::Mesh,
    file_name::String,
    boundaryElements::Set{Int64}
) -&gt; WriteVTK.DatasetFile
</code></pre><p>Open a new VTK output file and write the mesh data into it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L244">source</a></section><section><div><pre><code class="nohighlight hljs">open_vtkfile_boundary(
    mesh::Mesh,
    file_name::String;
    boundary = Set{Boundary}()
)</code></pre><p>Open a new VTK output file and write the mesh data into it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L280-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.save_vtkfile" href="#MinFEM.save_vtkfile"><code>MinFEM.save_vtkfile</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save_vtkfile(
    vtkfile::WriteVTK.DatasetFile
) -&gt; Vector{String}
</code></pre><p>Finalize a VTK file by writing all data to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.write_pointdata_vtkfile!" href="#MinFEM.write_pointdata_vtkfile!"><code>MinFEM.write_pointdata_vtkfile!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_pointdata_vtkfile!(vtkfile::WriteVTK.DatasetFile, data::Any, data_name::String)</code></pre><p>Add a new point data field with a name to an existing VTK file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.write_celldata_vtkfile!" href="#MinFEM.write_celldata_vtkfile!"><code>MinFEM.write_celldata_vtkfile!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_celldata_vtkfile!(
    vtkfile::WriteVTK.DatasetFile,
    data,
    data_name::String
) -&gt; LightXML.XMLElement
</code></pre><p>Add a new cell data field with a name to an existing VTK file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.write_to_txt" href="#MinFEM.write_to_txt"><code>MinFEM.write_to_txt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_to_txt(
    x::Vector{Float64},
    mesh::Mesh,
    file_name::String;
    qdim::Int64 = 1
)</code></pre><p>Writes a coefficient vector x with qdim components based on the nodes of mesh to the given file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L333-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MinFEM.read_from_txt" href="#MinFEM.read_from_txt"><code>MinFEM.read_from_txt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_from_txt(
    file_name::String
) -&gt; Tuple{Vector{Array{Float64, N} where N}, Vector{Float64}}
</code></pre><p>Reads node coordinates and finite element coefficient vector from file  generated by <a href="lib/@ref">write_to_txt</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MinFEM/MinFEM.jl/blob/1b684e7440370e108726e80cf00ba36b85600957/src/output.jl#L372">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#MinFEM.Boundary"><code>MinFEM.Boundary</code></a></li><li><a href="#MinFEM.Domain"><code>MinFEM.Domain</code></a></li><li><a href="#MinFEM.Mesh"><code>MinFEM.Mesh</code></a></li><li><a href="#MinFEM.PDESystem"><code>MinFEM.PDESystem</code></a></li><li><a href="#MinFEM.Region"><code>MinFEM.Region</code></a></li><li><a href="#MinFEM.assemble!"><code>MinFEM.assemble!</code></a></li><li><a href="#MinFEM.assemble_basismatrix"><code>MinFEM.assemble_basismatrix</code></a></li><li><a href="#MinFEM.assemble_basismatrix_boundary"><code>MinFEM.assemble_basismatrix_boundary</code></a></li><li><a href="#MinFEM.assemble_cubicderivativematrix"><code>MinFEM.assemble_cubicderivativematrix</code></a></li><li><a href="#MinFEM.assemble_cubicsecondderivativematrix"><code>MinFEM.assemble_cubicsecondderivativematrix</code></a></li><li><a href="#MinFEM.assemble_cubicterm"><code>MinFEM.assemble_cubicterm</code></a></li><li><a href="#MinFEM.assemble_derivativematrix"><code>MinFEM.assemble_derivativematrix</code></a></li><li><a href="#MinFEM.assemble_derivativematrix_boundary"><code>MinFEM.assemble_derivativematrix_boundary</code></a></li><li><a href="#MinFEM.assemble_dirichletcondition!"><code>MinFEM.assemble_dirichletcondition!</code></a></li><li><a href="#MinFEM.assemble_dirichletcondition_rhs!"><code>MinFEM.assemble_dirichletcondition_rhs!</code></a></li><li><a href="#MinFEM.assemble_dirichletprojection"><code>MinFEM.assemble_dirichletprojection</code></a></li><li><a href="#MinFEM.assemble_elasticity"><code>MinFEM.assemble_elasticity</code></a></li><li><a href="#MinFEM.assemble_laplacian"><code>MinFEM.assemble_laplacian</code></a></li><li><a href="#MinFEM.assemble_massmatrix"><code>MinFEM.assemble_massmatrix</code></a></li><li><a href="#MinFEM.assemble_massmatrix_boundary"><code>MinFEM.assemble_massmatrix_boundary</code></a></li><li><a href="#MinFEM.assemble_normalderivativematrix"><code>MinFEM.assemble_normalderivativematrix</code></a></li><li><a href="#MinFEM.assemble_weightmultivector"><code>MinFEM.assemble_weightmultivector</code></a></li><li><a href="#MinFEM.assemble_weightmultivector_boundary"><code>MinFEM.assemble_weightmultivector_boundary</code></a></li><li><a href="#MinFEM.barycenter"><code>MinFEM.barycenter</code></a></li><li><a href="#MinFEM.boundingbox"><code>MinFEM.boundingbox</code></a></li><li><a href="#MinFEM.conjugated_exponent"><code>MinFEM.conjugated_exponent</code></a></li><li><a href="#MinFEM.deform_mesh"><code>MinFEM.deform_mesh</code></a></li><li><a href="#MinFEM.deform_mesh!"><code>MinFEM.deform_mesh!</code></a></li><li><a href="#MinFEM.elementangle"><code>MinFEM.elementangle</code></a></li><li><a href="#MinFEM.elementbarycenter"><code>MinFEM.elementbarycenter</code></a></li><li><a href="#MinFEM.elementdiameter"><code>MinFEM.elementdiameter</code></a></li><li><a href="#MinFEM.elementdiameter_boundary"><code>MinFEM.elementdiameter_boundary</code></a></li><li><a href="#MinFEM.elementratio"><code>MinFEM.elementratio</code></a></li><li><a href="#MinFEM.elementvolume"><code>MinFEM.elementvolume</code></a></li><li><a href="#MinFEM.elementvolume_boundary"><code>MinFEM.elementvolume_boundary</code></a></li><li><a href="#MinFEM.evaluate_function"><code>MinFEM.evaluate_function</code></a></li><li><a href="#MinFEM.evaluate_mesh_function"><code>MinFEM.evaluate_mesh_function</code></a></li><li><a href="#MinFEM.evaluate_quadrature_function"><code>MinFEM.evaluate_quadrature_function</code></a></li><li><a href="#MinFEM.evaluate_quadrature_function_boundary"><code>MinFEM.evaluate_quadrature_function_boundary</code></a></li><li><a href="#MinFEM.export_mesh"><code>MinFEM.export_mesh</code></a></li><li><a href="#MinFEM.extract_elements"><code>MinFEM.extract_elements</code></a></li><li><a href="#MinFEM.extract_nodes"><code>MinFEM.extract_nodes</code></a></li><li><a href="#MinFEM.grad_phi"><code>MinFEM.grad_phi</code></a></li><li><a href="#MinFEM.import_mesh"><code>MinFEM.import_mesh</code></a></li><li><a href="#MinFEM.integral_over_reference_element"><code>MinFEM.integral_over_reference_element</code></a></li><li><a href="#MinFEM.jacobian"><code>MinFEM.jacobian</code></a></li><li><a href="#MinFEM.jacobian_boundary"><code>MinFEM.jacobian_boundary</code></a></li><li><a href="#MinFEM.open_vtkfile"><code>MinFEM.open_vtkfile</code></a></li><li><a href="#MinFEM.open_vtkfile_boundary"><code>MinFEM.open_vtkfile_boundary</code></a></li><li><a href="#MinFEM.outernormalvector"><code>MinFEM.outernormalvector</code></a></li><li><a href="#MinFEM.phi"><code>MinFEM.phi</code></a></li><li><a href="#MinFEM.pnorm"><code>MinFEM.pnorm</code></a></li><li><a href="#MinFEM.pnorm_boundary"><code>MinFEM.pnorm_boundary</code></a></li><li><a href="#MinFEM.prolong_multivector"><code>MinFEM.prolong_multivector</code></a></li><li><a href="#MinFEM.qnorm"><code>MinFEM.qnorm</code></a></li><li><a href="#MinFEM.qnorm_boundary"><code>MinFEM.qnorm_boundary</code></a></li><li><a href="#MinFEM.quadrature_order"><code>MinFEM.quadrature_order</code></a></li><li><a href="#MinFEM.quadrature_points"><code>MinFEM.quadrature_points</code></a></li><li><a href="#MinFEM.quadrature_points_boundary"><code>MinFEM.quadrature_points_boundary</code></a></li><li><a href="#MinFEM.quadrature_weights"><code>MinFEM.quadrature_weights</code></a></li><li><a href="#MinFEM.quadrature_weights_boundary"><code>MinFEM.quadrature_weights_boundary</code></a></li><li><a href="#MinFEM.read_from_txt"><code>MinFEM.read_from_txt</code></a></li><li><a href="#MinFEM.refresh!"><code>MinFEM.refresh!</code></a></li><li><a href="#MinFEM.restrict_multivector"><code>MinFEM.restrict_multivector</code></a></li><li><a href="#MinFEM.save_vtkfile"><code>MinFEM.save_vtkfile</code></a></li><li><a href="#MinFEM.select_boundaries"><code>MinFEM.select_boundaries</code></a></li><li><a href="#MinFEM.select_domains"><code>MinFEM.select_domains</code></a></li><li><a href="#MinFEM.solve!"><code>MinFEM.solve!</code></a></li><li><a href="#MinFEM.stripwidth"><code>MinFEM.stripwidth</code></a></li><li><a href="#MinFEM.twonorm"><code>MinFEM.twonorm</code></a></li><li><a href="#MinFEM.twonorm_boundary"><code>MinFEM.twonorm_boundary</code></a></li><li><a href="#MinFEM.unit_interval"><code>MinFEM.unit_interval</code></a></li><li><a href="#MinFEM.unit_square"><code>MinFEM.unit_square</code></a></li><li><a href="#MinFEM.update_mesh!"><code>MinFEM.update_mesh!</code></a></li><li><a href="#MinFEM.volume"><code>MinFEM.volume</code></a></li><li><a href="#MinFEM.write_celldata_vtkfile!"><code>MinFEM.write_celldata_vtkfile!</code></a></li><li><a href="#MinFEM.write_pointdata_vtkfile!"><code>MinFEM.write_pointdata_vtkfile!</code></a></li><li><a href="#MinFEM.write_to_txt"><code>MinFEM.write_to_txt</code></a></li><li><a href="#MinFEM.write_to_vtk"><code>MinFEM.write_to_vtk</code></a></li><li><a href="#MinFEM.write_to_vtk_boundary"><code>MinFEM.write_to_vtk_boundary</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/parabolic/">« A Time-Dependent Problem</a><a class="docs-footer-nextpage" href="../internal/">Internal »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 27 September 2024 11:31">Friday 27 September 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
