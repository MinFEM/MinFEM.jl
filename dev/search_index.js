var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internal-Documentation","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"CurrentModule = MinFEM","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for MinFEM.jl's internal types and functions.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"See the Public page of the library for the documentation of the public interface.","category":"page"},{"location":"lib/internals/#Contents","page":"Internals","title":"Contents","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nDepth = 2","category":"page"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Entity","category":"page"},{"location":"lib/internals/#MinFEM.Entity","page":"Internals","title":"MinFEM.Entity","text":"Entity\n\nType holding the associated physical tag and the set of elements for one gmsh elementary entity.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Mesh-Import","page":"Internals","title":"Mesh Import","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"import_mesh1\nimport_mesh2\nimport_mesh4\ngetDimFromGMSHElementType\ngetGMSHElementTypeFromDim\ngetParentBoundary","category":"page"},{"location":"lib/internals/#MinFEM.import_mesh1","page":"Internals","title":"MinFEM.import_mesh1","text":"import_mesh1(f::IOStream) -> Mesh\n\nReturns mesh by continuing import process started by import_mesh() for gmsh files of version 1. \n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.import_mesh2","page":"Internals","title":"MinFEM.import_mesh2","text":"import_mesh2(f::IOStream) -> Mesh\n\nReturns mesh by continuing import process started by import_mesh() for gmsh files of version 2. \n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.import_mesh4","page":"Internals","title":"MinFEM.import_mesh4","text":"import_mesh4(f::IOStream) -> Mesh\n\nReturns mesh by continuing import process started by import_mesh()  for gmsh files of version 4. \n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.getDimFromGMSHElementType","page":"Internals","title":"MinFEM.getDimFromGMSHElementType","text":"getDimFromGMSHElementType(t::Int64) -> Int64\n\nReturns dimension of a gmsh elementary entitiy type.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.getGMSHElementTypeFromDim","page":"Internals","title":"MinFEM.getGMSHElementTypeFromDim","text":"getGMSHElementTypeFromDim(d::Int64) -> Int64\n\nReturns gmsh elementary element type for given dimension.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.getParentBoundary","page":"Internals","title":"MinFEM.getParentBoundary","text":"getParentBoundary(nodes::Vector{Int64}, parentNodes::Vector{Int64}) -> Int64\n\nReturns index of the boundary of the parent element spanned by the nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Quadrature","page":"Internals","title":"Quadrature","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"gausslegendre_points\ngausslegendre_weights\ncompute_coordinates_line\ncompute_coordinates_triangle\ncompute_coordinates_tetrahedron\ncompute_weights_line\ncompute_weights_triangle\ncompute_weights_tetrahedron","category":"page"},{"location":"lib/internals/#MinFEM.gausslegendre_points","page":"Internals","title":"MinFEM.gausslegendre_points","text":"gausslegendre_points(order::Int64) -> Array{Float64,1}\n\nReturns coordinates of the Gauss-Legendre quadrature points on the default interval [-1,1]  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.gausslegendre_weights","page":"Internals","title":"MinFEM.gausslegendre_weights","text":"gausslegendre_weights(order::Int64) -> Array{Float64,1}\n\nReturns weights of the Gauss-Legendre quadrature points on the default interval [-1,1]  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_coordinates_line","page":"Internals","title":"MinFEM.compute_coordinates_line","text":"compute_coordinates_line(order::Int64) -> Array{Array{Float64,1},1}\n\nReturns coordinates of the Gauss-Legendre quadrature points  on the 1-dimensional FEM reference element [0,1]  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_coordinates_triangle","page":"Internals","title":"MinFEM.compute_coordinates_triangle","text":"compute_coordinates_triangle(order::Int64) -> Array{Array{Float64,1},1}\n\nReturns coordinates of the Gauss-Legendre quadrature points  on the 2-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_coordinates_tetrahedron","page":"Internals","title":"MinFEM.compute_coordinates_tetrahedron","text":"compute_coordinates_tetrahedron(order::Int64) -> Array{Array{Float64,1},1}\n\nReturns coordinates of the Gauss-Legendre quadrature points  on the 3-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_weights_line","page":"Internals","title":"MinFEM.compute_weights_line","text":"compute_weights_line(order::Int64) -> Array{Float64,1}\n\nReturns weights of the Gauss-Legendre quadrature points  on the 1-dimensional FEM reference element [0,1]  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_weights_triangle","page":"Internals","title":"MinFEM.compute_weights_triangle","text":"compute_weights_triangle(order::Int64) -> Array{Float64,1}\n\nReturns weights of the Gauss-Legendre quadrature points  on the 2-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.compute_weights_tetrahedron","page":"Internals","title":"MinFEM.compute_weights_tetrahedron","text":"compute_weights_tetrahedron(order::Int64) -> Array{Float64,1}\n\nReturns weights of the Gauss-Legendre quadrature points  on the 3-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"stressTensor\nstrainTensor","category":"page"},{"location":"lib/internals/#MinFEM.stressTensor","page":"Internals","title":"MinFEM.stressTensor","text":"stressTensor(grad::AbstractMatrix, lambda::Float64, mu::Float64)\n\nReturns the local stress tensor for linear elasticity  with constant coefficients λ, μ and gradient as argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MinFEM.strainTensor","page":"Internals","title":"MinFEM.strainTensor","text":"strainTensor(grad::AbstractMatrix)\n\nReturns the local strain tensor for linear elasticity with gradient as argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Index","page":"Internals","title":"Index","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nModule = [\"MinFEM\"]\nOrder = [:type, :function]","category":"page"},{"location":"paraview/#Visualization-with-Paraview","page":"Visualization","title":"Visualization with Paraview","text":"","category":"section"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"MinFEM is designed to output files in .vtu-format in order to visualize them with Paraview, which is an industry-standard open-source application. While it might be beneficial for the future to have experience with such a tool, on the other hand it also offers some simple-to-use features you can utilize to generate (colorful) images of your work. Therefore, this page will give you a short walk-through for the basic features of Paraview.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"The application itself can be obtained for all common operating systems from the official website, where you can also find more detailed tutorials. We recommend to choose the latest stable version or optionally, for already experienced users, if you want to generate truly non-rasterized .svg-files, a 4.x version.","category":"page"},{"location":"paraview/#Open-a-File","page":"Visualization","title":"Open a File","text":"","category":"section"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Assume you already created a .vtu-file, e.g by solving one of our example problems. If not please proceed with that, e.g. Geting Started, and then return here later.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"When opening the Paraview GUI, it should look similar to the following image, where you can click on the button in the top left corner to open the file selection dialog. (Image: Paraview GUI)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Now navigate to the desired .vtu-file, select it and click on OK. If you want to open multiple files, you can also do so by holding the ctrl-key and select on multiple files.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Open File Dialog)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"After opening a file it will appear in the pipeline browser on the left, but will not be active yet. To activate it, make sure the file is selected in the browser and hit the green apply button. While this procedure feels a little unhandy for our purpose here, for larger files it becomes important to customize properties a priori. ","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Apply Button)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"After applying the file, your main window will show a grey surface with the shape of your domain. To view the computed solution you need to change the coloring to the dataset, which can be done via the dropdown menu at the top or in the properties below the pipeline browser. If you wrote multiple datasets to the file, e.g. also a source term, you can also switch between them and compare them.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Coloring Dropdown)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"In the end, your GUI might look the following image. Note that the actual look depends on your color mapping, which can be can be changed via the button with the folder and the heart on the right. There you can choose from a range of different presets. Further, it is often more useful to see level sets instead of a continuous coloring. In order to reach that, simply reduce the number of table values in the lower right corner.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Visualization)","category":"page"},{"location":"paraview/#Export-a-Screenshot","page":"Visualization","title":"Export a Screenshot","text":"","category":"section"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"After you visualized your solution, you might also want to share it, for example in a presentation. Since you do not want to open Paraview all the time, you can export the current scene, i.e. the blue framed center element, as a screenshot. Therefore hit the respective button on top.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Screenshot Button)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"This will open a file dialog, where you can specify a path and the name, your screenshot shall be saved under. Confirm by clicking OK.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Screenshot File Dialog)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Next, there is a dialog for options. You do not have to change anything her, however it often comes in handy, to make the background transparent by checking the respective box. Further, the initial resolution depends on your display and should often be increased. The easiest ways to do so are by clicking on the x button and then select x2 in the dropdown or use the lock button to fix the ratio and then change one number manually. Finally, save the screenshot by hitting OK.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Screenshot Settings Dialog)","category":"page"},{"location":"paraview/#Open-a-Sequence","page":"Visualization","title":"Open a Sequence","text":"","category":"section"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Sometimes you do not want to open just a single file, but e.g. all the files for a time sequence or intermediate results of an iterative process. Enter the file dialog the same way, you did for a single file. Paraview automatically groups files, that have a similar name, e.g. with a running index at the end numbering the time steps. So already keep this in mind, when generating and naming your files. Select the (multi-)file and hit OK.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Open File Sequence)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Proceed the like for a single file.  Apply it in the pipeline and change the coloring to the intended dataset. For a sequence of files, you now additionally want to fit the scale to all time steps. Otherwise it is just based on the first frame and you might end up seeing no change in time. Therefore, click the respective button in the top menu.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Rescale all Time Steps)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Since this procedure could take very long for large datasets, you will get a warning. However, this should not be relevant for your use cases and thus confirm it. After that, you might see that the scale in the main window has changed. ","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Rescaling Confirmation)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Now you can start the (time) animation by clicking the play button in the controls at the top of the window. This will run the animation once for all time steps. Of course, you can also skip to the beginning and the end, click through single frames or loop the animation.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Play Button)","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Time View)","category":"page"},{"location":"paraview/#Export-an-Animation","page":"Visualization","title":"Export an Animation","text":"","category":"section"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"Similar to exporting a single screenshot, you can also directly export a sequence of screenshots for all steps. Therefore, access the save animation option via the file menu in the top left corner. This will open the same dialogs as for the single screenshot, so proceed as before. In the end you will end up, with a file for each time step, where the name is appended by a running index, so you might consider saving them to a separate folder. Later, you could externally generate a video or a gif from those images.","category":"page"},{"location":"paraview/","page":"Visualization","title":"Visualization","text":"(Image: Save Animation)","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"CurrentModule = MinFEM","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for MinFEM.jl's public interface.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"See the Internals page of the library for the documentation  of internal types and functions.","category":"page"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nDepth = 3","category":"page"},{"location":"lib/public/#Module","page":"Public","title":"Module","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"MinFEM","category":"page"},{"location":"lib/public/#MinFEM.MinFEM","page":"Public","title":"MinFEM.MinFEM","text":"MinFEM\n\nA minimal finite element tool for demonstration and teaching in julia.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Types","page":"Public","title":"Types","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Mesh\nBoundary\nDomain\nPDESystem","category":"page"},{"location":"lib/public/#MinFEM.Mesh","page":"Public","title":"MinFEM.Mesh","text":"Mesh\n\nType for a triangular finite element mesh with volume and boundary markers.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MinFEM.Boundary","page":"Public","title":"MinFEM.Boundary","text":"Boundary\n\nStructure holding the name and sets of node and edge indices for one particular physical boundary.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MinFEM.Domain","page":"Public","title":"MinFEM.Domain","text":"Domain\n\nType holding the name and the set of element indices for one particular physical domain.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#MinFEM.PDESystem","page":"Public","title":"MinFEM.PDESystem","text":"PDESystem\n\nStructure holding all information to describe simple PDEs  with Dirichlet boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Functions-and-Methods","page":"Public","title":"Functions and Methods","text":"","category":"section"},{"location":"lib/public/#Mesh-Generation","page":"Public","title":"Mesh Generation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"unit_interval\nunit_square\nimport_mesh\nexport_mesh\ndeform_mesh!\ndeform_mesh","category":"page"},{"location":"lib/public/#MinFEM.unit_interval","page":"Public","title":"MinFEM.unit_interval","text":"unit_interval(n::Int64) -> Mesh\n\nReturns an n nodes quasi-uniform mesh for the 1D unit interval. The left boundary node is denoted by 1001 and the right one by 1002.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.unit_square","page":"Public","title":"MinFEM.unit_square","text":"unit_square(n::Int64) -> Mesh\n\nReturns a n-by-n quasi-uniform mesh for the 2D unit square. The boundary indices are given in the order bottom, top, left, right from 1001 to 1004.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.import_mesh","page":"Public","title":"MinFEM.import_mesh","text":"import_mesh(fileName::String) -> Mesh\n\nReturns a mesh imported from a gmsh file of version v1, v2 or v4.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.export_mesh","page":"Public","title":"MinFEM.export_mesh","text":"export_mesh(mesh::Mesh, fileName::String)\n\nExports a mesh to a gmsh file of version v2.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.deform_mesh!","page":"Public","title":"MinFEM.deform_mesh!","text":"deform_mesh!(mesh::Mesh, v::AbstractVector{Float64}; t::Float64=1.0)\n\nDeforms given mesh by shifting all nodes according to the vector field v  scaled by the stepsize t.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.deform_mesh","page":"Public","title":"MinFEM.deform_mesh","text":"deform_mesh(mesh::Mesh, v::AbstractVector{Float64}; t::Float64=1.0) -> Mesh\n\nReturns copy of mesh deformed by deform_mesh!.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Type-Handling","page":"Public","title":"Type Handling","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"select_boundaries\nextract_elements\nextract_nodes","category":"page"},{"location":"lib/public/#MinFEM.select_boundaries","page":"Public","title":"MinFEM.select_boundaries","text":"select_boundaries(mesh::Mesh, args...) -> Set{Boundary}\n\nReturns set of all or specified physical boundaries of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.extract_elements","page":"Public","title":"MinFEM.extract_elements","text":"extract_elements(boundaries::Set{Boundary}) -> Set{Int64}\nextract_elements(domains::Set{Domain}) -> Set{Int64}\n\nReturns set of boundary element ids in set of physical regions.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.extract_nodes","page":"Public","title":"MinFEM.extract_nodes","text":"extract_nodes(boundaries::Set{Boundary}) -> Set{Int64}\nextract_nodes(domains::Set{Domain}) -> Set{Int64}\n\nReturns set of node ids in set of physical regions.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Function-Discretization","page":"Public","title":"Function Discretization","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"evaluate_mesh_function","category":"page"},{"location":"lib/public/#MinFEM.evaluate_mesh_function","page":"Public","title":"MinFEM.evaluate_mesh_function","text":"evaluate_mesh_function(mesh::Mesh, f::Function;\n                        region=Set{Int64}(), qdim=1) -> Vector{Float64}\nevaluate_mesh_function(mesh::Mesh, f::Function, region::Set{Boundary};\n                        qdim = 1) -> Vector{Float64}\n\nReturns evaluation of a given function object f on all or specified nodes of the mesh. Can be either called with set of physical boundaries or directly with a set of nodes  when given with keyword argument region.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Mesh-(Element)-Properties","page":"Public","title":"Mesh (Element) Properties","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"jacobian\njacobian_boundary\nelementvolume\nelementvolume_boundary\nelementdiameter\nelementdiameter_boundary\nouternormalvector\nstripwidth\nboundingbox\nvolume\nbarycenter","category":"page"},{"location":"lib/public/#MinFEM.jacobian","page":"Public","title":"MinFEM.jacobian","text":"jacobian(coords::Vector{Vector{Float64}}) -> Float64, Matrix{Float64}\njacobian(mesh::Mesh, nodes::Array{Int64,1}) -> Float64, Matrix{Float64}\njacobian(mesh::Mesh, element::Int64) -> Float64, Matrix{Float64}\n\nReturns determinant (i.e. element weight) and inverse transposed of the jacobian  of an FEM element spanned by the given nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.jacobian_boundary","page":"Public","title":"MinFEM.jacobian_boundary","text":"jacobian_boundary(coords::Vector{Vector{Float64}}) -> Float64\njacobian_boundary(mesh::Mesh, nodes::Array{Int64,1}) -> Float64\njacobian_boundary(mesh::Mesh, element::Int64) -> Float64\n\nReturns determinant of the jacobian (i.e. element weight)  of an FEM boundary element (in d-1 dimensions) spanned by the given nodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.elementvolume","page":"Public","title":"MinFEM.elementvolume","text":"elementvolume(mesh::Mesh) -> Vector{Float64}\nelementvolume(mesh::Mesh, element::Int64) -> Float64\nelementvolume(d::Int64) -> Float64\n\nReturns volume of all or one element(s) in a mesh  or of the d-dimensional reference element. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.elementvolume_boundary","page":"Public","title":"MinFEM.elementvolume_boundary","text":"elementvolume_boundary(mesh::Mesh) -> Vector{Float64}\nelementvolume_boundary(mesh::Mesh, element::Int64) -> Float64\nelementvolume_boundary(d::Int64) -> Float64\n\nReturns volume of all or one boundary element(s) in a mesh. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.elementdiameter","page":"Public","title":"MinFEM.elementdiameter","text":"elementdiameter(mesh::Mesh) -> Vector{Float64}\nelementdiameter(mesh::Mesh, element::Int64) -> Float64\nelementdiameter(mesh::Mesh, nodes::Vector{Int64}) -> Float64\nelementdiameter(nodes::Vector{Vector{Float64}}) -> Float64\n\nReturns diameter (i.e. longest edge length) of all or one element(s) in a mesh  or of an element spanned by the given nodes or coordinates (not necessarily of full dimension).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.elementdiameter_boundary","page":"Public","title":"MinFEM.elementdiameter_boundary","text":"elementdiameter_boundary(mesh::Mesh) -> Vector{Float64}\nelementdiameter_boundary(mesh::Mesh, element::Int64) -> Float64\n\nReturns diameter (i.e. longest edge length) of all or one boundary element(s) in a mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.outernormalvector","page":"Public","title":"MinFEM.outernormalvector","text":"outernormalvector(mesh::Mesh; boundaryElements::Set{Int64}=Set{Int64}()) \n    -> Vector{Float64}\nouternormalvector(mesh::Mesh, boundaryElement::Int64) \n    -> Vector{Float64}\nouternormalvector(mesh::Mesh, boundaryElement::Int64, J::AbstractMatrix{Float64})\n    -> Vector{Float64}\nouternormalvector(dim::Int64, ii::Int64) \n    -> Vector{Float64}\n\nReturns the outer normal vector at specified boundary element(s) of the boundary  of the mesh or at the ii-th boundary of the dim-dimensional reference element. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.stripwidth","page":"Public","title":"MinFEM.stripwidth","text":"stripwidth(mesh::Mesh) -> Float64\n\nReturn width L of a strip that the meshed domain fits into.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.boundingbox","page":"Public","title":"MinFEM.boundingbox","text":"boundingbox(mesh::Mesh) -> Array{Float64}\n\nReturn two nodes, which span the bounding box of the mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.volume","page":"Public","title":"MinFEM.volume","text":"volume(mesh::Mesh) -> Float64\n\nReturns the d-dimenional volume of the domain definded by the mesh. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.barycenter","page":"Public","title":"MinFEM.barycenter","text":"barycenter(mesh::Mesh) -> Vector{Float64}\n\nReturns the d-dimenional domain of the domain definded by the mesh. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Local-Quadrature","page":"Public","title":"Local Quadrature","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"quadrature_points\nquadrature_weights\nquadrature_order\nintegral_over_reference_element","category":"page"},{"location":"lib/public/#MinFEM.quadrature_points","page":"Public","title":"MinFEM.quadrature_points","text":"quadrature_points(d::Int64, order::Int64) -> Array{Array{Float64,1},1}\n\nReturns coordinates of the Gauss-Legendre quadrature points  on the d-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\nquadrature_points(mesh::Mesh, order::Int64) -> Array{Array{Float64,1},1}\n\nReturns global coordinates of the Gauss-Legendre quadrature points  on each finite element in the given mesh for exact integration of polynomials up to the given order.\n\n\n\n\n\nquadrature_points(element::Int64, mesh::Mesh, order::Int64) -> Array{Array{Float64,1},1}\n\nReturns global coordinates of the Gauss-Legendre quadrature points  on a specified element in the given mesh for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.quadrature_weights","page":"Public","title":"MinFEM.quadrature_weights","text":"quadrature_weights(d::Int64, order::Int64) -> Array{Float64,1}\n\nReturns weights of the Gauss-Legendre quadrature points  on the d-dimensional FEM reference element  for exact integration of polynomials up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.quadrature_order","page":"Public","title":"MinFEM.quadrature_order","text":"quadrature_order(d::Int64, n::Int64) -> Int64\n\nReturns highest quadrature order archived by using n points in d dimensions.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.integral_over_reference_element","page":"Public","title":"MinFEM.integral_over_reference_element","text":"integral_over_reference_element(f::Function, d::Int64;order::Int64=1) -> Float64\n\nReturns integral of function f over the d-dimensional FEM reference element  computed with Gauss-Legendre quadrature exact at least for polynomials up to given order. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Vector-Valued-Coefficients-Handling","page":"Public","title":"Vector-Valued Coefficients Handling","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"prolong_multivector\nrestrict_multivector","category":"page"},{"location":"lib/public/#MinFEM.prolong_multivector","page":"Public","title":"MinFEM.prolong_multivector","text":"prolong_multivector(x::AbstractVector{Float64}, m::Int64, qdim::Int64; \n                    block::Int64=1) -> Vector{Float64}\n\nProlongates a vector of m blocks of size block to a multivector  for qdim dimensions of length qdim×block×m.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.restrict_multivector","page":"Public","title":"MinFEM.restrict_multivector","text":"restrict_multivector(x::AbstractVector{Float64}, m::Int64, qdim::Int64;\n                        block::Int64=1) -> Vector{Float64}\n\nRestricts a multivector of qdim×block×m elements for qdim dimensions  to the regular vector of m blocks of size block.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Weight-Computation","page":"Public","title":"Weight Computation","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"assemble_weightmultivector\nassemble_weightmultivector_boundary","category":"page"},{"location":"lib/public/#MinFEM.assemble_weightmultivector","page":"Public","title":"MinFEM.assemble_weightmultivector","text":"assemble_weightmultivector(mesh::Mesh; qdim::Int64=1, order::Int64=1) \n    -> Vector{Float64}\n\nReturns the vector of weights for all elements of mesh and image dimension qdim. Weight is equal to volume if 1st order integration by mid-point rule is used.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_weightmultivector_boundary","page":"Public","title":"MinFEM.assemble_weightmultivector_boundary","text":"assemble_weightmultivector_boundary(mesh::Mesh; qdim::Int64=1, order::Int64=1) \n    -> Vector{Float64}\n\nReturns the vector of weights for all boundary elements of mesh and image dimension qdim. Weight is equal to volume if 1st order integration by mid-point rule is used.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Finite-Element-Basis-Functions","page":"Public","title":"Finite Element Basis Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"phi\ngrad_phi","category":"page"},{"location":"lib/public/#MinFEM.phi","page":"Public","title":"MinFEM.phi","text":"phi(ii::Int64, x::AbstractVector) -> Float64\n\nReturns ii-th local basis function evaluated at x.  Dimension is determined by length(x). \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.grad_phi","page":"Public","title":"MinFEM.grad_phi","text":"grad_phi(d::Int64, ii::Int64) -> Float64\n\nGradient of ii-th local basis functions in d dimensions. Note that the gradient is constant on an element.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#FE-Operator-Assembly","page":"Public","title":"FE Operator Assembly","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"assemble_derivativematrix\nassemble_laplacian\nassemble_derivativematrix_boundary\nassemble_normalderivativematrix\nassemble_basismatrix\nassemble_massmatrix\nassemble_basismatrix_boundary\nassemble_massmatrix_boundary\nassemble_cubicterm\nassemble_cubicderivativematrix\nassemble_cubicsecondderivativematrix\nassemble_elasticity","category":"page"},{"location":"lib/public/#MinFEM.assemble_derivativematrix","page":"Public","title":"MinFEM.assemble_derivativematrix","text":"assemble_derivativematrix(mesh::Mesh; qdim::Int64=1) -> SparseMatrixCSC{Float64, Int64}\n\nReturns the discrete derivative matrix for all elements of mesh and image dimension qdim.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_laplacian","page":"Public","title":"MinFEM.assemble_laplacian","text":"assemble_laplacian(mesh::Mesh; qdim::Int64=1) \n    -> SparseMatrixCSC{Float64, Int64}\nassemble_laplacian(D::SparseMatrixCSC{Float64, Int64}, w::AbstractVector{Float64}) \n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the Laplacian stiffness matrix for all elements of mesh and image dimension qdim. Can either be assembled directly or from derivative matrix and weight vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_derivativematrix_boundary","page":"Public","title":"MinFEM.assemble_derivativematrix_boundary","text":"assemble_derivativematrix_boundary(mesh::Mesh; \n                                    boundaryElements::Set{Int64}=Set{Int64}(), \n                                    qdim::Int64=1) \n                                    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the discrete derivative matrix for all or specied boundary elements  of mesh and image dimension qdim. Workaround based on the derivate tensor for the corresponding full element and the fact that the gradient ist constant on the element. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_normalderivativematrix","page":"Public","title":"MinFEM.assemble_normalderivativematrix","text":"assemble_normalderivativematrix(mesh::Mesh;\n                                boundaryElements::Set{Int64}=Set{Int64}(),\n                                qdim::Int64=1) \n                                -> SparseMatrixCSC{Float64, Int64}\n\nReturns the discrete normal derivative matrix for all or specied boundary elements  of mesh and image dimension qdim. Workaround based on the derivate tensor for the corresponding full element and the fact that the gradient ist constant on the element. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_basismatrix","page":"Public","title":"MinFEM.assemble_basismatrix","text":"assemble_basismatrix(mesh::Mesh; qdim::Int64=1) -> SparseMatrixCSC{Float64, Int64}\n\nReturns the discrete basis matrix with given local integration order  for all elements of mesh and image dimension qdim.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_massmatrix","page":"Public","title":"MinFEM.assemble_massmatrix","text":"assemble_massmatrix(mesh::Mesh; qdim::Int64=1, order::Int64=1)\n    -> SparseMatrixCSC{Float64, Int64}\nassemble_massmatrix(E::SparseMatrixCSC{Float64, Int64}, w::AbstractVector{Float64})\n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the mass matrix with given local integration order for all elements  of mesh and image dimension qdim. Can either be assembled directly or from derivative matrix and weight vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_basismatrix_boundary","page":"Public","title":"MinFEM.assemble_basismatrix_boundary","text":"assemble_basismatrix_boundary(mesh::Mesh; \n                                boundaryElements::Set{Int64}=Set{Int64}(),\n                                qdim::Int64=1, order::Int64=1) \n                                -> SparseMatrixCSC{Float64, Int64}\n\nReturns the discrete basis matrix with given local integration order for all or specified boundary elements of mesh and image dimension qdim.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_massmatrix_boundary","page":"Public","title":"MinFEM.assemble_massmatrix_boundary","text":"assemble_massmatrix_boundary(mesh::Mesh; \n                                boundaryElements::Set{Int64}=Set{Int64}(), \n                                qdim::Int64=1, order::Int64=1)\n                                -> SparseMatrixCSC{Float64, Int64}\nassemble_massmatrix_boundary(E::SparseMatrixCSC{Float64, Int64},\n                                w::AbstractVector{Float64})\n                                -> SparseMatrixCSC{Float64, Int64}\n\nRetruns the mass matrix with given local integration order  for all or specified boundary elements of mesh and image dimension qdim. Can either be assembled directly or from derivative matrix and weight vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_cubicterm","page":"Public","title":"MinFEM.assemble_cubicterm","text":"assemble_cubicterm(mesh::Mesh, y::AbstractVector; order::Int64=3)\n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the cubic term of the standard semilinear parabolic equation.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_cubicderivativematrix","page":"Public","title":"MinFEM.assemble_cubicderivativematrix","text":"assemble_cubicderivativematrix(mesh::Mesh, y::AbstractVector; order::Int64=3)\n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the linearization of the cubic term of the standard semilinear elliptic equation.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_cubicsecondderivativematrix","page":"Public","title":"MinFEM.assemble_cubicsecondderivativematrix","text":"assemble_cubicsecondderivativematrix(mesh::Mesh, y::AbstractVector,\n                                        p::AbstractVector; order::Int64=3)\n                                        -> SparseMatrixCSC{Float64, Int64}\n\nReturns the second derivative of the cubic term  of the standard semilinear elliptic equation around the state y.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_elasticity","page":"Public","title":"MinFEM.assemble_elasticity","text":"assemble_elasticity(mesh::Mesh, lambda::Float64, mu::Float64) \n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the linear elasticity stiffness matrix with constant coefficients λ and μ  for all elements of mesh and image dimension qdim.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Boundary-Condition-Handling","page":"Public","title":"Boundary Condition Handling","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"assemble_dirichletcondition!\nassemble_dirichletprojection","category":"page"},{"location":"lib/public/#MinFEM.assemble_dirichletcondition!","page":"Public","title":"MinFEM.assemble_dirichletcondition!","text":"assemble_dirichletcondition!(A, DI::Set{Int64}; \n                                rhs=[], bc=[], qdim::Int64=1, insert=1.0)\nassemble_dirichletcondition!(A, DI::Set{Boundary};\n                                rhs=[], bc=[], qdim::Int64=1, insert=1.0)\n\nModify a stiffness matrix and a right hand side according to the given Dirichlet conditions. DI has to be the set of node indices for which the condition should be active. For vector valued states either DI can be set to each component that should have a Dirichlet condtion or qdim is set, if all components should have the condition. The value insert is put as diagonal element. Usually you want a 1.0 here.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble_dirichletprojection","page":"Public","title":"MinFEM.assemble_dirichletprojection","text":"assemble_dirichletprojection(nnodes::Int64, DI::Set{Int64}; qdim::Int64=1) \n    -> SparseMatrixCSC{Float64, Int64}\n\nReturns the projection matrix onto the Dirichlet nodes  where the input ncoeffs is understood as qdim*nnodes.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#FE-Extensions","page":"Public","title":"FE Extensions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"pnorm\nqnorm\npnorm_boundary\nqnorm_boundary\nconjugated_exponent","category":"page"},{"location":"lib/public/#MinFEM.pnorm","page":"Public","title":"MinFEM.pnorm","text":"pnorm(p::Float64,v::AbstractVector{Float64}, mesh::Mesh; \n        qdim::Int64=1, order::Int64=1) -> Float64\n\nReturns L^p-norm of a FEM coefficient vector v over the nodes  or quadrature points in the elements on the given mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.qnorm","page":"Public","title":"MinFEM.qnorm","text":"qnorm(p::Float64,v::AbstractVector{Float64}, mesh::Mesh; \n        qdim::Int64=1, order::Int64=1) -> Float64\n\nReturns L^q-norm of a function f or its FEM coefficient vector v on the given mesh with q being the conjugated exponent to p.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.pnorm_boundary","page":"Public","title":"MinFEM.pnorm_boundary","text":"pnorm_boundary(p::Float64, v::AbstractVector{Float64}, mesh::Mesh; \n                boundaryElements::Set{Int64}=Set{Int64}(), \n                qdim::Int64=1, order::Int64=1) -> Float64\n\nReturns L^p-norm of a FEM coefficient vector v over the nodes or quadrature points  in the boundary elements on the given mesh.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.qnorm_boundary","page":"Public","title":"MinFEM.qnorm_boundary","text":"qnorm_boundary(p::Float64, v::AbstractVector{Float64}, mesh::Mesh; \n                boundaryElements::Set{Int64}=Set{Int64}(), \n                qdim::Int64=1, order::Int64=1) -> Float64\n\nReturns L^q-norm of a function f or its FEM coefficient vector v on the given mesh with q being the conjugated exponent to p.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.conjugated_exponent","page":"Public","title":"MinFEM.conjugated_exponent","text":"conjugated_exponent(p::Float64) -> Float64\n\nReturns conjugated exponent q to p in the Hölder sense 1/p + 1/q = 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#PDE-System-Handling","page":"Public","title":"PDE System Handling","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"solve!\nassemble!\nrefresh!","category":"page"},{"location":"lib/public/#MinFEM.solve!","page":"Public","title":"MinFEM.solve!","text":"solve!(S::PDESystem)\n\nFirst tries to set up the system matrix with multipliers for Dirichlet conditions. If the system has already been used before, this step is skipped. This is determined depending on an existing factorization of the system matrix. If the stiffness matrix or Dirichlet conditions have changes,  one should invole refresh() first. Finally the system is solved via matrix factorization.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.assemble!","page":"Public","title":"MinFEM.assemble!","text":"assemble!(S::PDESystem)\n\nIf the system has not been used before, sets up the system matrix  with multipliers for Dirichlet conditions and factorizes it.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.refresh!","page":"Public","title":"MinFEM.refresh!","text":"refresh!(S::PDESystem)\n\nRecomputes the factorization of the stiffness matrix using assemble!().\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Output","page":"Public","title":"Output","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"write_to_vtk\nwrite_to_vtk_boundary\nopen_vtkfile\nopen_vtkfile_boundary\nsave_vtkfile\nwrite_pointdata_vtkfile!\nwrite_celldata_vtkfile!\nwrite_to_txt\nread_from_txt","category":"page"},{"location":"lib/public/#MinFEM.write_to_vtk","page":"Public","title":"MinFEM.write_to_vtk","text":"write_to_vtk(x::Vector{Vector{Float64}}, mesh::Mesh, dataName::Array{String}, \n                fileName::String, qdim::Array{Int64})\nwrite_to_vtk(x::Vector{Vector{Float64}}, mesh::Mesh, dataNames::Array{String}, \n                fileName::String; qdim::Int64=1)\nwrite_to_vtk(x::Vector{Float64}, mesh::Mesh, dataName::String, \n                fileName::String; qdim::Int64=1)\n\nWrites one or multiple vectors with variable qdim corrsponding to the mesh nodes  to a VTK file. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.write_to_vtk_boundary","page":"Public","title":"MinFEM.write_to_vtk_boundary","text":"write_to_vtk_boundary(x::Vector{Vector{Float64}}, mesh::Mesh, \n                        dataName::Array{String}, fileName::String, \n                        qdim::Array{Int64}; boundary=Set{Boundary}())\nwrite_to_vtk_boundary(x::Vector{Vector{Float64}}, mesh::Mesh,\n                        dataNames::Array{String}, fileName::String; \n                        boundary=Set{Boundary}(), qdim::Int64=1)\nwrite_to_vtk_boundary(x::Vector{Float64}, mesh::Mesh, \n                        dataName::String, fileName::String; \n                        boundary=Set{Boundary}(), qdim::Int64=1)\n\nWrites one or multiple vectors with variable qdim corrsponding to the mesh  boundary elements to a VTK file. \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.open_vtkfile","page":"Public","title":"MinFEM.open_vtkfile","text":"open_vtkfile(mesh::Mesh, file_name::String) -> WriteVTK.DatasetFile\n\nOpen a new VTK output file and write the mesh data into it.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.open_vtkfile_boundary","page":"Public","title":"MinFEM.open_vtkfile_boundary","text":"open_vtkfile_boundary(mesh::Mesh, file_name::String, boundaryElements=Set{Int64}())\nopen_vtkfile_boundary(mesh::Mesh, file_name::String; boundary=Set{Boundary}())\n\nOpen a new VTK output file and write the mesh data into it.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.save_vtkfile","page":"Public","title":"MinFEM.save_vtkfile","text":"save_vtkfile(vtkfile::WriteVTK.DatasetFile)\n\nFinalize a VTK file by writing all data to disk.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.write_pointdata_vtkfile!","page":"Public","title":"MinFEM.write_pointdata_vtkfile!","text":"write_pointdata_vtkfile!(vtkfile::WriteVTK.DatasetFile, data::Any, data_name::String)\n\nAdd a new point data field with a name to an existing VTK file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.write_celldata_vtkfile!","page":"Public","title":"MinFEM.write_celldata_vtkfile!","text":"write_celldata_vtkfile!(vtkfile::WriteVTK.DatasetFile, data::Any, data_name::String)\n\nAdd a new cell data field with a name to an existing VTK file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.write_to_txt","page":"Public","title":"MinFEM.write_to_txt","text":"write_to_txt(x::Vector{Float64}, mesh::Mesh, fileName::String; qdim::Int64=1)\n\nWrites a coefficient vector x based on the nodes of mesh to the given file.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#MinFEM.read_from_txt","page":"Public","title":"MinFEM.read_from_txt","text":"read_from_txt(fileName::String)\n\nReads node coordinates and finite element coefficient vector from file  generated by write_to_txt.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Index","page":"Public","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]\nModule = [\"MinFEM\"]\nOrder = [:type, :function]","category":"page"},{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"MinFEM.jl is available as an registered Julia package and thus the installation  can be done quickly using the package manager. To do so, open the julia REPL, hit the ] key to change into the package mode. The line will now start with something like (@v1.7) pkg> where the numbers denote  you current minor julia version, indicating that you are modifying your full installation. In case there is a package name featured instead,  because you managed dependencies of it before, you need to restart the full REPL. Now you can add the package by typing","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add MinFEM\ntest MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"If you are interested in modifying the code, you might also clone the GitHub repository  from here to your local machine. Then you can add it as a development package to your Julia installation  by using the package tool in the REPL as before and typing","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"dev C:\\your\\path\\to\\minfem\ntest MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"From now on, you can use MinFEM by including it on top of you code file","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using MinFEM","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"In general the workflow starts by creating a mesh of the computational domain. This can either be done by importing a GMSH file or using the internal functions  for creating a unit mesh.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"mesh = import_mesh(\"../meshes/square.msh\")\n\nmesh = unit_square(50)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Subsequently, you can specify physical boundary sets that are used to specify boundary conditions later on. The general syntax returns you a set of the type Boundary, which contains either all physical boundaries specified, or just the selected indices. The indices are either specified in the GMSH file or for the unit meshes given in their respective documentation. Here, 1001 and 1003 select the bottom and left boundary of the unit square. For some applications you might need the all the nodes or elements of a boundary set.  These can be easily extracted and are then given by an unordered set Set{Int64}.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"boundary = select_boundaries(mesh)\nboundary = select_boundaries(mesh, 1001, 1003)\n\nboundaryNodes = extract_nodes(boundary)\nboundaryNodes = extract_elements(boundary)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Next, operators can be assembled.  There are multiple operators available all following the same syntax. For a full list check the Public Documentation page, here we only introduce the two most basic ones.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"L = assemble_laplacian(mesh)\nM = assemble_massmatrix(mesh)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"While one could now manually code the solution of the finite element linear system, MinFEM supports the creation of a PDESystem. With this you can set up the linear system as you would in a classical sense and automatically add boundary conditions. Then simply solve the system and the solution will be contained in the object.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"pde = PDESystem(A=L, b=M*ones(mesh.nnodes), bc=zeros(mesh.nnodes), DI=boundaryNodes)\nsolve!(pde)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Finally, you can write the solution to a file. Most commonly, this will be a .vtu file to be read with Paraview for visualization. For the storage of intermediate result it might also be useful to save it as a simple .txt file. This can be read later on and could also be used for visualization with Plots.jl.","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"write_to_vtk(pde.state, mesh, \"u\", \"getting_started\")\n\nwrite_to_txt(pde.state, mesh, \"u\", \"getting_started\")","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For more detailed tutorial workflows check out the Examples section of this manual. These will include multiple operators as well as a time dependent problem, a non-linear problem and how to handle vector-valued functions.","category":"page"},{"location":"fem/#A-Closer-Look-on-a-Finite-Element-Code","page":"The Finite Element Method","title":"A Closer Look on a Finite Element Code","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"This section is designed to give a small introduction to the implementation of a finite element method, illustrated for 2 dimensions.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Pages = [\"fem.md\"]\nDepth = 3","category":"page"},{"location":"fem/#The-Reference-Element","page":"The Finite Element Method","title":"The Reference Element","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"The first thing we will cover is the so-called reference element. This is a prototypic element such that we later do not have to define everything for each actual element, but can do it in a generic way. MinFEM uses tetrahedral elements and the reference element is thus given by the d-dimensional standard simplex","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"T = leftlbrace x in 01^d sum_j=1^d x_j leq 1rightrbrace","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For this guide, we will work mostly in 2D, where this is simply the reference triangle","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"T = lbrace x in 01^2 x_1+x_2 leq 1rbrace","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Reference Element)","category":"page"},{"location":"fem/#Local-Basis-Functions-on-T","page":"The Finite Element Method","title":"Local Basis Functions on T","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"On T we can define order p=1 Lagrange Polynomials","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"phi T to mathbbR","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"using the vertices v_l l=1d+1 as nodes such that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"phi_l(v_l^prime) = delta_ll^prime","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"we obtain the basis functions","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"phi_l(x) = begincases\n    1 - sum_j=1^d x_j  textif  l = 1\n    x_l-1  textelse\nendcases","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"in 2 dimension looking the following:","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Local Basis Functions)","category":"page"},{"location":"fem/#The-Global-Basis-Functions","page":"The Finite Element Method","title":"The Global Basis Functions","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"On a patch of, e.g., five physical triangles we then have a global basis function  Phi_i Omega to mathbbR of the following form:","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Global Basis Function)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Since with each node x_i in the mesh one global basis function Phi_i is associated we have the property","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Phi_i(x_j) = delta_ij","category":"page"},{"location":"fem/#Quadrature-Nodes-on-Triangles","page":"The Finite Element Method","title":"Quadrature Nodes on Triangles","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"The next step is to define some quadrature nodes with weights on T. In principle, every set of distinct nodes with appropriate weights can be used for  quadrature.  Here we use a tensorproduct Gauss formula, since for these types the approximation order is known.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Quadrature Formula)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"The presented quadrature rule allows exact integration of polynomials of order up to p=3.","category":"page"},{"location":"fem/#Using-Quadrature-Formulas","page":"The Finite Element Method","title":"Using Quadrature Formulas","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"In principle, we could integrate terms like ","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Phi_i Phi_j","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"or ","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"nabla Phi_i cdot nabla Phi_j","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"analytically since we only consider p=1 Lagrange elements.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"It is yet convenient to use quadrature formulas for, e.g., a nonlinear source term.","category":"page"},{"location":"fem/#Mapping-Reference-to-Physical-Elements","page":"The Finite Element Method","title":"Mapping Reference to Physical Elements","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"In order to integrate over a physical triangle in the mesh T_k, we need to establish a mapping between T_k and the reference element T via a function","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"psi_k T to T_k","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Physical Element)","category":"page"},{"location":"fem/#Integration-Over-the-Reference-Element-via-Transformation-Formula","page":"The Finite Element Method","title":"Integration Over the Reference Element via Transformation Formula","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For linear finite elements with the chosen reference element T we can map each point r in T to a x in T_k by the affine mapping","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"x = psi_k(r) = J_k r + b_k","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Here J_k in mathbbR^2times 2 and b_kin mathbbR^2 is constant for each triangle.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Element Mapping)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Further, let w_1 w_2 w_3 be the vertices of the triangle T_k. The matrix J_k is then given by","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"J_k = w_2 - w_1 vert w_3 - w_1 quad textand quad b_k = w_1","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Integration of a function f in L^1(T_k) over T_k is thus performed by integration over T as","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"beginaligned\nint_T_k f(x) dx = int_T f(psi_k(x)) vertdet(Dpsi_k(x))vert  dx\n= int_T f(psi_k(x))   vertdet(J_k)vert  dx\nendaligned","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"By ensuring that in all physical elements T_k the node numbering is counter clockwise, like in the reference element T, it follows det(J_k) geq 0 and we can omit the modulus. Moreover, as long as T_k is not degenerated it follows det(J_k)  0.","category":"page"},{"location":"fem/#Mapping-From-Local-to-Global-Nodes","page":"The Finite Element Method","title":"Mapping From Local to Global Nodes","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For every finite element code the mapping from local nodes in each triangle to the corresponding global node numbers is essential.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Let the mesh be given by the triangles lbrace T_1dots T_Krbrace and a number of N nodes and thus the global basis functions.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For this mesh we assume a given map ","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"etalbrace 1 dots Krbrace times lbrace123rbrace to lbrace 1 dots Nrbrace\n eta(kl) = i","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"which assigns the l-th node in the k-th triangle the corresponding global node i.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Phi_i Omega to mathbbR i=1dotsN","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Further observe that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"mathrmspt(Phi_i) subset lbrace T_1dots T_Krbrace","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"More precisely","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"mathrmspt(Phi_i) = lbrace T_k exists (kl) in lbrace 1 dots Krbrace times\nlbrace123rbrace textwith eta(kl) = i rbrace","category":"page"},{"location":"fem/#Link-Between-Global-and-Local-Basis-Functions","page":"The Finite Element Method","title":"Link Between Global and Local Basis Functions","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Let the global basis function Phi_iOmega to mathbbR be associated with the node i.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"We then have the property that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Phi_i (x) = phi_l(psi^-1_k(x))quad forall xin T_k","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"provided that eta(kl) = i.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Thus, we can use the following relation for integration on physical elements","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Phi_i(psi_k(x)) = phi_l(x) quad forall  x in T","category":"page"},{"location":"fem/#Mass-Matrix-Assembly","page":"The Finite Element Method","title":"Mass Matrix Assembly","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Recall that one entry of the mass matrix is given by","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"beginaligned\nM_ij = int_Omega Phi_i(x) Phi_j(x) dx\n        = sum_k=1^K int_T_k Phi_i(x) Phi_j(x) dx\n        = sum_k=1^K int_T_k phi_l(psi^-1_k(x)) phi_h(psi^-1_k(x)) dx\n        = sum_k=1^K int_T phi_l(x) phi_h(x) vert mathrmdet(J_k)vert dx\nendaligned","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"provided that eta(kl) = i and eta(kh) = j. In principal, the sum above involves many vanishing summands. It is sufficient to sum over all T_k in mathrmspt(Phi_i) cap mathrmspt(Phi_j).","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"In order to assemble this matrix for 1leq ij leq N it is algorithmically more efficient to iterate over triangles rather than iterating over global basis functions by i and j.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"We thus compute the following","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"M_n(kl) n(kh) gets M_n(kl) n(kh) + int_T phi_l(x) phi_h(x)\n    vert mathrmdet(J_k)vert dx quad forall (khl)\n    in lbrace1dotsKrbracetimes lbrace 123 rbrace^2","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"This saves us the computational effort to find out which T_k is in mathrmspt(Phi_i) cap mathrmspt(Phi_j).","category":"page"},{"location":"fem/#Treatment-of-Terms-With-Derivatives","page":"The Finite Element Method","title":"Treatment of Terms With Derivatives","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"In the following we understand derivatives as row vectors","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D phi = (partial_1 phi partial_2 phi)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"and the Jacobian matrix of a vector valued function, e.g. the element transformation, as","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D psi = \nbeginpmatrix\npartial_1 psi_1  partial_2 psi_1\npartial_1 psi_2  partial_2 psi_2\nendpmatrix","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For terms which involve gradients we first observe that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D Phi_i(x) = D phi_l(psi_k^-1(x)) D psi_k^-1 =\nD phi_l(psi_k^-1(x)) J_k^-1quad forall xin T_k","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"provided that eta(kl) = i. And thus","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D Phi_i(psi_k(x)) = D phi_l(x) J_k^-1quad forall  x in T","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Due to the fact that we only consider piece-wise linear basis functions we obtain","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D Phi_i = Dphi_l J_k^-1","category":"page"},{"location":"fem/#Towards-the-Stiffness-Matrix-for-the-Laplacian","page":"The Finite Element Method","title":"Towards the Stiffness Matrix for the Laplacian","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Recall that the stiffness matrix for the Laplacian is defined as","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"L_ij = int_Omega D Phi_i(x) cdot D Phi_j(x) dx =\nint_Omega D Phi_i cdot D Phi_j dx","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Following the same argumentation as for the mass matrix, the stiffness matrix can be computed by","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"L_n(kl) n(kh) gets L_n(kl) n(kh) +\nint_T (D phi_l J_k^-1) cdot (D phi_h J_k^-1)\nvert mathrmdet(J_k)vert dx forall (khl) in\nlbrace1dotsKrbracetimes lbrace 123 rbrace^2","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"The general structure of a code, which assembles stiffness or mass matrix, is based on three nested loops. The outermost loop iterates over all triangles, then one loop over three basis functions and the innermost loop iterates over three test functions.","category":"page"},{"location":"fem/#Example-Calculation-for-the-Stiffness-Matrix","page":"The Finite Element Method","title":"Example Calculation for the Stiffness Matrix","text":"","category":"section"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Consider the following domain as Omega","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Simple Grid)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"As an example we assume piece-wise linear basis functions and compute one entry of the stiffness matrix of the Laplacian","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"L_13 = int_Omega D Phi_1 cdot D Phi_3 dx","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"which corresponds to the basis function Phi_1 located in w_1 and Phi_3 in w_3.","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Inspecting the support of D Phi_1 cdot D Phi_3 we see that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"L_13 = int_T_1 D Phi_1 cdot D Phi_3 dx + int_T_4 D Phi_1 cdot D Phi_3 dx","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Let the transformation function for T_1 be given by psi_1 T to T_1 such that psi_1(v_1) = w_1 psi_1(v_2) = w_2 psi_3(v_3) = w_3 as sketched below","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"(Image: Element Mapping)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Thus, we obtain","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Psi_1(v) = J_1 v + w_1 quad J_1 = w_2 - w_1 vert w_3 - w_1 =\nbeginpmatrix a  fraca2 0  fracb2 endpmatrix","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"For the triangle T_4 we obtain similarly by choosing  psi_4(v_1) = w_4 psi_4(v_2) = w_1 psi_4(v_3) = w_3 that","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Psi_4(v) = J_4 v + w_4 quad J_4 = w_1 - w_4 vert w_3 - w_4 =\nbeginpmatrix 0  fraca2 -b  -fracb2 endpmatrix","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"Recall the mapping eta(li) in lbrace 123 rbrace which assigns the global node number i to the local node number eta(li) in the l-th triangle. Using this notation we obtain eta(13) = 3 eta(11) = 1 and eta(43) = 3 eta(41) = 2. Further, recall that local basis functions phi_n T to mathbbR are chosen as","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"phi_n (v_j) = delta_nj quad 1leq nj leq 3","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"such that we obtain","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"D phi_1 = (-1-1) D phi_2 = (10) D phi_3 = (01)","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"We also compute","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"J_1^-1 = frac2ab beginpmatrix fracb2  -fraca2 0  a endpmatrix\nquad textand quad mathrmdet(J_1) = fracab2","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"J_4^-1 = frac2ab beginpmatrix -fracb2  -fraca2 b  0 endpmatrix\nquad textand quad mathrmdet(J_4) = fracab2","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"We can thus conclude","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"int_T_1 D Phi_1 cdot D Phi_3 dx = int_T (D phi_1  J^-1_1) cdot\n(D phi_3 J^-1_1) vert mathrmdet(J_1)vert dx = - fraca2b","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"and","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"int_T_4 D Phi_1 cdot D Phi_3 dx = int_T (D phi_2 J^-1_4) cdot\n(D phi_3 J^-1_4) vert mathrmdet(J_4)vert dx = - fracb2a","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"which results in ","category":"page"},{"location":"fem/","page":"The Finite Element Method","title":"The Finite Element Method","text":"L_13 = int_T_1 D Phi_1 cdot D Phi_3 dx + int_T_4 D Phi_1 cdot\nD Phi_3 dx = - fraca2b - fracb2a","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"using Markdown, MinFEM\nMarkdown.parse_file(joinpath(pkgdir(MinFEM), \"LICENSE\"))","category":"page"},{"location":"examples/boundary_source/#A-Boundary-Source-Problem","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"","category":"section"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"In the next example we concentrate on a boundary source term problem given by","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"beginaligned\n-Delta y = 0 quad textin Omega\ny = 0 quad texton Gamma_0\nfracpartial ypartial n = f quad texton Gamma_s\nendaligned","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"where the boundary Gamma = Gamma_0 cup Gamma_s is assumed to be composed of two disjoint parts.","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"Let V = lbrace v in H^1(Omega) vvert_Gamma_0 = 0mathrmae rbrace. The variational formulation then reads as:","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"Find y in V such that","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"int_Omega nabla y cdot  nabla v dx = int_Gamma_s f v  ds\nquad forall v in V","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"We now import a more interesting mesh and select the bottom and right boundary to be Gamma_0 as well as the left and top boundary to be Gamma_s by","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"using MinFEM\nmesh = import_mesh(\"../meshes/rounded.msh\")\n\nfreeBoundary = select_boundaries(mesh, 1003, 1004)\nfreeElements = extract_elements(freeBoundary)\ndirichletBoundary = select_boundaries(mesh, 1001, 1002)\ndirichletNodes = extract_nodes(dirichletBoundary)","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"The assembly of the stiffness matrix of the Laplacian is the same as for the plain Poisson problem. However, the mass matrix now has to discretize an integral over the boundary Gamma_s. ","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"int_Gamma_s f v  ds quad forall v in V","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"We thus call a different assembly routine, where we can specify the boundary elements to be Gamma_s. Note that, if no boundary elements would be specified, the method will assume all physical boundaries of the mesh.","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"L = assemble_laplacian(mesh)\nM = assemble_massmatrix_boundary(mesh, boundaryElements=freeElements)","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"Then we define an inline function f, which we want to evaluate at the boundary nodes of Gamma_s:","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"f(x) = x[1]^2 + x[2]^2\ns = evaluate_mesh_function(mesh, f, freeBoundary)","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"Notice that","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"length(s) == mesh.nnodes","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"although s is intend to be defined on the boundary only. Yet, it is more comfortable to define s on all finite element nodes with 0 else than to keep track of which value belongs to which node.","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"Finally, we assemble PDE, solve it and write the output to a file for Paraview:","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"pde = PDESystem(A=L, b=M*s, bc=zeros(mesh.nnodes), DI=dirichletNodes)\nsolve!(pde)\n\nwrite_to_vtk([pde.state, s], mesh, [\"Y\",\"S\"], \"boundary_source\")","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"In Paraview, the visualization should then look similar to the following:","category":"page"},{"location":"examples/boundary_source/","page":"A Boundary Source Problem","title":"A Boundary Source Problem","text":"(Image: Result)","category":"page"},{"location":"examples/elasticity/#A-Vector-Valued-Problem","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"","category":"section"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"Consider the vector-valued problem for the displacements u Omega to mathbbR^2 of the form","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"beginaligned\n-mathrmdiv(u) = 0 quad textin Omega\nsigma(u) cdot n = f quad texton Gamma_1\nu = 0 quad texton Gamma_2\nendaligned","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"in terms of the stress tensor","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"mathrmdiv(u) = lambda mathrmtr(epsilon(u)) I + 2 mu epsilon(u)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"strain tensor","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"epsilon(u) = frac12left( nabla u + nabla u^T right)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"and Lamé parameter lambda mu geq 0. The variational formulation is given by: Find u in V such that","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"int_Omega sigma(u)  epsilon(v)dx =\nint_Gamma_1 fcdot v  ds quad forall  v in V","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"where V=lbrace vin (H^1(Omega))^2 v = 0 text ae on  Gamma_2rbrace.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"We start again by importing the mesh file and selecting the physical boundaries for the problem.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"using MinFEM\nmesh = import_mesh(\"../meshes/square.msh\")\n\nforcingBoundary = select_boundaries(mesh, 1001)\nfixedBoundary = select_boundaries(mesh, 1003)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"Next we assemble the stiffness matrix with the (not very meaningful) Lamé parameter lambda = 1, mu = 1 as well as the boundary mass matrix.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"L = assemble_elasticity(mesh, 1.0, 1.0)\nMb = assemble_massmatrix_boundary(mesh, boundaryElements=extract_elements(forcingBoundary),\n                                    qdim=2)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"Here, the last argument qdim=2 states that the operator shall be assembled for a vector-valued problem with the respective image dimension. This is necessary for most operations, but notably not for the elasticity assembly, since the operator can only be vector-valued anyways.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"Now, we define the source term on the upper boundary. It reflects simply a constant force in force in x_1-direction.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"f(x) = [0.1, 0.0]\ns = evaluate_mesh_function(mesh, f, region=extract_nodes(forcingBoundary), qdim=2)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"In the next step we set up the PDE system and enforce the Dirichlet condition. Again, the last argument qdim=2 specifies that this is a vector-valued function.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"pde = PDESystem(A=L, b=Mb*s, bc=zeros(2*mesh.nnodes), DI=extract_nodes(fixedBoundary),\n                qdim=2)\nsolve!(pde)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"The final step is the output to a Paraview file, quite similar as before. Please note, that image dimension 2 is internally a special case. A zero x_3-component is appended in order to generate a virtually 3-dimensional output, which is required by Paraview for several filters, e.g. \"warp by vector\".","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"write_to_vtk([pde.state, s], mesh, [\"Y\",\"S\"], \"elasticity\", qdim=2)","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"In Paraview, the visualization should then look similar to the following figures. The first image shows magnitude of the (vector-valued) solution and the second one still the magnitude, but now on the domain deformed by the field.","category":"page"},{"location":"examples/elasticity/","page":"A Vector-Valued Problem","title":"A Vector-Valued Problem","text":"(Image: Result) (Image: Result)","category":"page"},{"location":"examples/parabolic/#A-Parabolic-Problem","page":"A Time-Dependent Problem","title":"A Parabolic Problem","text":"","category":"section"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"Consider the heat equation with constant heating f=1 as an example for a time dependent PDE.","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"beginaligned\nu_t -Delta u = f quad textin Omega times (0T)\nu = 0 quad texton partialOmega times (0T)\nu = 0 quad texton Omega times  0\nendaligned","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"We start by discretizing the problem uniformly in time with a finite difference approach. Here, we include theta in 01 in order to mix implicit and explicit time stepping, where theta=1 means fully implicit and theta=0 fully explicit.","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"fracu^k-u^k-1Delta t - Delta(theta u^k + (1-theta )u^k-1) = f","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"Then, for every time step k in mathbbN, we need to solve the variational problem:  Find u^k in H_0^1(Omega) such that","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"int_Omega fracu^k-u^k-1Delta t v mathrmdx +\nint_Omega nabla (theta u^k + (1-theta )u^k-1) cdot nabla v mathrmdx =\nint_Omega f v mathrmdx","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"for all v in H_0^1(Omega).","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"We now multiply by Delta t and move every known quantity to the right side","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"int_Omega u^k v mathrmdx + \nthetaDelta t int_Omega nabla u^k cdot nabla v mathrmdx =\nint_Omega u^k-1 v mathrmdx -\n(1-theta)Delta t int_Omega nabla u^k-1 cdot nabla v mathrmdx +\nint_Omega f v mathrmdx","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"leading to the discrete formulation in terms of finite elements reading","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"(M + thetaDelta t L) u^k = (M+(theta-1)Delta t L) u^k-1 + Mf","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"The following function implements a time loop to solve the problem on the interval 0T in tsteps timesteps and outputs a .vtu-file for each step to a folder:","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"using MinFEM\n\nfunction parabolic(mesh::Mesh, boundaryIndices::Set{Int64},\n                    L::AbstractMatrix, M::AbstractMatrix,\n                    f::AbstractVector, u::AbstractVector,\n                    T::Float64, tsteps::Int; theta=1.0)\n\n    dt = (T-0)/tsteps\n\n    path = \"parabolic_problem/\"\n    mkpath(path)\n    write_to_vtk(u, mesh, \"u\", path*\"parabolic_\"*lpad(string(0), 3, '0')*\".vtu\")\n\n    for i = 1:tsteps\n        pde = PDESystem(A=(M + theta*dt*L), b=(M - (1.0-theta)*dt*L)*u + dt*M*f,\n                        bc=zeros(mesh.nnodes), DI=boundaryIndices)\n        solve!(pde)\n\n        u = copy(pde.state)\n\n        write_to_vtk(u, mesh, \"u\", path*\"parabolic_\"*lpad(string(i), 3, '0')*\".vtu\")\n    end\n\nend","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"The rest of the code is then again similar to the Poisson problem:","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"mesh = import_mesh(\"../meshes/Lshaped.msh\")\n\nboundary = select_boundaries(mesh)\nboundary_nodes = extract_nodes(boundary)\n\nsource(x) = 1.0\nf = evaluate_mesh_function(mesh, source)\n\ninitial_condition(x) = 0.0\nu = evaluate_mesh_function(mesh, initial_condition)\n\nL = assemble_laplacian(mesh)\nM = assemble_massmatrix(mesh)\n\nparabolic(mesh, boundary_nodes, L, M, f, u, 1.5, 100, theta=1.0)","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"From Paraview, you can access the folder created and open the file parabolic_*..vtu, which will automatically load all time steps. You can then run it via the Play button, as also explained in the tutorial. The final visualization should look similar to the following:","category":"page"},{"location":"examples/parabolic/","page":"A Time-Dependent Problem","title":"A Time-Dependent Problem","text":"(Image: Result)","category":"page"},{"location":"examples/poisson/#A-Poisson-Problem","page":"A Poisson Problem","title":"A Poisson Problem","text":"","category":"section"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Lets go through a code for the Poisson equation on a unit square","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Omega = (01)^2","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"and","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Gamma = partial Omega","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"with homogeneous Dirichlet boundary conditions given by","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"beginaligned\n-Delta y = s quad textin Omega\ny = 0 quad texton Gamma\nendaligned","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"First we have to load the package MinFEM. We then import a mesh file generated with GMSH. Here it is assumed that square.msh is located inside a mesh/ folder in the parent directory ../. This has to be adjusted if using Windows.  Notice the line being commented out. For simplicitity we could also generate a uniform mesh for the unit square (01)^2 with, e.g., 30 nodes in each direction:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"using MinFEM\nmesh = import_mesh(\"../meshes/square.msh\");\n#mesh = unit_square(30);","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"using MinFEM\nmesh = unit_square(30)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Now we can inspect the content of the new object:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"fieldnames(typeof(mesh))","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Important for us is the field Boundaries assigning markers to the physical boundaries:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"keys(mesh.Boundaries)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"We can thus see that there are four boundaries. The naming scheme (1001, 1002, 1003, 1004) was more or less arbitrarily chosen during the creation of the mesh and could be changed. Lets inspect one of them:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"fieldnames(typeof(mesh.Boundaries[1001]))","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"mesh.Boundaries[1001]","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"The next step is to assemble the matrices which discretize the weak formulation:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Find y in H_0^1(Omega) such that","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"int_Omega nabla y cdot nabla v dx = int_Omega s v dx","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"for all v in H_0^1(Omega).","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"So we need a stiffness matrix","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"L = assemble_laplacian(mesh)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"and a mass matrix","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"M = assemble_massmatrix(mesh)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"We now want to set","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"s_mn(x) = sin(n x_1 pi)sin(m x_2 pi)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"as an eigenfunction of the Laplacian multiplied with the corresponding eigenvalue","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"lambda_mn = (npi)^2 + (mpi)^2","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"n=3\nm=2\nf(x) = ((n*pi)^2 + (m*pi)^2) * sin(n*x[1]*pi) * sin(m*x[2]*pi)\ns = evaluate_mesh_function(mesh, f)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Finally we plan to solve: Find y in H_0^1(Omega) such that","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"int_Omega nabla y cdot nabla v dx = int_Omega lambda_mn s_mn v dx","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"for all v in H_0^1(Omega). Where we know that the exact, also classical solution, is given by","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"y(x) = s_mn(x)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Therefore, we set up a PDESystem structure, which holds all necessary information for the PDE. These are the stiffness matrix, the load vector, Dirichlet values and indices of the boundary nodes:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"boundary = select_boundaries(mesh, 1001, 1002, 1003, 1004)\nboundaryNodes = extract_nodes(boundary)\n\npde = PDESystem(A=L, b=M*s, bc=zeros(mesh.nnodes), DI=boundaryNodes)","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Remember that the mesh was designed to have four physical boundaries identified by the indices 1001-1004.","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"Finally, we solve the PDE and write the solution as well as the prescribed load to a .vtu-file for visualization with Paraview:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"solve!(pde)\n\nwrite_to_vtk([pde.state, s], mesh, [\"Y\",\"S\"], \"poisson\")","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"In Paraview, the visualization of the solution should then look similar to the following:","category":"page"},{"location":"examples/poisson/","page":"A Poisson Problem","title":"A Poisson Problem","text":"(Image: Result)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: MinFEM Logo)","category":"page"},{"location":"#MinFEM.jl","page":"Home","title":"MinFEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A minimal finite element tool for demonstration and teaching.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Linear Lagrange basis functions.\nSupport for isoparametric tetrahedral grids in 1D, 2D and 3D.\nImport of meshes from GMSH in formats v1, v2 and v4.\nOutput in .vtu-format for Paraview or simple .txt.\nSeveral illustrative demonstration problems.\nExtensive documentation.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package aims to provide an easy and minimalistic introduction  to the finite element method. This documentation is designed to enable you to quickly code, solve and visualize your first own finite element problems in julia, without preliminary knowledge required.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by a brief introduction to the theoretical construction of finite elements, basis functions and operator assembly in the section The Finite Element Method. Then the Getting Started page explains how to start using MinFEM in julia and code an easy example. Subsequently, we show how to use basic features of the industrial-grade application Paraview to display your obtained results on the Visualization page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, the Examples section features some detailed demonstrations for different types of problems that can be solved using a finite element approach, where the original code files are in addition available in the  GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/poisson.md\",\n    \"examples/boundary_source.md\",\n    \"examples/elasticity.md\",\n    \"examples/semilinear.md\",\n    \"examples/parabolic.md\"\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more experienced users, we further offer the Library with a full list of types, functions and methods provided by MinFEM featuring explicit documentation. This also includes extensions of the finite element method not used for the tutorials showed in this documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"lib/public.md\", \"lib/internals.md\"]\nDepth = 1","category":"page"},{"location":"examples/semilinear/#A-Semi-Linear-Problem","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"","category":"section"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"In the following we discuss a non-linear example. The so-called standard, semilinear PDE given by","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"beginaligned\n-Delta y + y^3 = f quad textin Omega\ny = 0 quad texton Gamma\nendaligned","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"The variational form reads as follows: Find y in H_0^1(Omega) such that","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"int_Omega nabla y cdot nabla v dx + int_Omega y^3  v dx = int_Omega f v dx","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"for all v in H_0^1(Omega).","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"Note that this is a non-linear equation in y. In order to apply Newton's method we have to differentiate with respect to y.","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"The linearization evaluated in y in direction w is given by","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"int_Omega nabla w cdot nabla v dx + 3 int_Omega y^2 w v dx","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"Consequently, one step of Newton's method is given by the solution of the variational problem: Find w in H^1_0(Omega) such that","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"int_Omega nabla w cdot nabla v dx + 3 int_Omega y^2 w v dx =\n-int_Omega nabla y cdot nabla v dx - int_Omega y^3  v dx + int_Omega f v dx","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"for all v in H_0^1(Omega).","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"We thus introduce the function assemble_cubicterm and assemble_cubicderivativematrix in order to assemble the source term involving y^3 and the matrix with y^2, respectively.","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"Most of the code is similar to the Poisson example. We thus illuminate what is required additionally. The function semilinear evaluates Newton's method for the problem described above with a tolerance tol:","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"using MinFEM, LinearAlgebra\n\nfunction semilinear(mesh::Mesh, L::AbstractMatrix, M::AbstractMatrix,\n                    s::AbstractVector, boundaryIndices::Set{Int64};\n                    tol::Float64=1e-10, maxIterations::Int64=10)\n\n    y = zeros(mesh.nnodes)\n\n    pde = PDESystem(A=L, b=M*s, bc=zeros(mesh.nnodes), DI=boundaryIndices)\n\n    for i = 1:maxIterations\n        pde.A = L + assemble_cubicderivativematrix(mesh, y)\n        pde.b = -L*y + M*s - assemble_cubicterm(mesh, y)\n        refresh!(pde)\n        solve!(pde)\n\n        y += pde.state\n        res = norm(pde.state)\n\n        if res < tol\n            println(\"It. $i: $res < $tol\")\n            println(\"Semi-linear routine converged.\")\n            break\n        else\n            println(\"It. $i: $res ≥ $tol\")\n\n            if i == maxIterations\n                println(\"Semi-linear routine failed.\")\n                println(\"Maximum number of iterations reached.\")\n            end\n        end\n    end\n    \n    return y\nend","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"The rest of the code is then similar to the Poisson problem:","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"mesh = import_mesh(\"../meshes/Zshaped.msh\")\n\nL = assemble_laplacian(mesh)\nM = assemble_massmatrix(mesh)\n\nf(x) = 3*2*pi^2*sin(x[1]*pi)*sin(x[2]*pi) + (3*sin(x[1]*pi)*sin(x[2]*pi))^3\ns = evaluate_mesh_function(mesh, f)\n\nboundary = select_boundaries(mesh)\nboundaryNodes = extract_nodes(boundary)\n\ny = semilinear(mesh, L, M, s, boundaryNodes)\n\nwrite_to_vtk([y, s], mesh, [\"y\",\"s\"], \"semilinear\")","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"In Paraview, the visualization should then look similar to the following:","category":"page"},{"location":"examples/semilinear/","page":"A Semi-Linear Problem","title":"A Semi-Linear Problem","text":"(Image: Result)","category":"page"}]
}
